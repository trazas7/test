/**
 * Walks the entire presentation and returns all textual content.
 * - Slides + (if available) Notes Pages
 * - Text frames, tables, and nested groups
 */
export async function getWholeDeckText(): Promise<string> {
  return PowerPoint.run(async (context) => {
    const pres = context.presentation;
    const parts: string[] = [];

    // helper to walk shapes recursively and collect text
    const walkShapes = async (scoped: PowerPoint.ShapeScopedCollection) => {
      scoped.load("items/type");
      await context.sync();

      const frames: PowerPoint.TextFrame[] = [];
      const tables: PowerPoint.Table[] = [];
      const recurse: PowerPoint.ShapeScopedCollection[] = [];

      for (const shape of scoped.items) {
        if (shape.type === PowerPoint.ShapeType.group) {
          recurse.push(shape.group.shapes);
        } else if (shape.type === PowerPoint.ShapeType.table) {
          const table = shape.getTable();
          table.load("values,rowCount,columnCount");
          tables.push(table);
        } else {
          const tf = shape.getTextFrameOrNullObject();
          tf.load("hasText,textRange/text");
          frames.push(tf);
        }
      }
      await context.sync();

      // collect text frames
      for (const tf of frames) {
        if (!tf.isNullObject && tf.hasText && tf.textRange && typeof tf.textRange.text === "string") {
          const t = (tf.textRange.text || "").trim();
          if (t) parts.push(t);
        }
      }

      // collect table cell text
      for (const tb of tables) {
        for (let r = 0; r < tb.rowCount; r++) {
          for (let c = 0; c < tb.columnCount; c++) {
            const t = (tb.values[r][c] ?? "").toString().trim();
            if (t) parts.push(t);
          }
        }
      }

      // recurse into grouped shapes
      for (const inner of recurse) {
        await walkShapes(inner);
      }
    };

    // iterate all slides
    const slides = pres.slides;
    slides.load("items");
    await context.sync();

    for (const slide of slides.items) {
      await walkShapes(slide.shapes);

      // notes page text (if available in client)
      const notesPage = (slide as any).notesPage;
      if (notesPage?.shapes) {
        await walkShapes(notesPage.shapes);
      }
    }

    return parts.join("\n\n");
  });
}
