/**
 * Return all text in the presentation (slides + notes when available),
 * independent of any selection.
 */
export async function getWholeDeckText(): Promise<string> {
  return PowerPoint.run(async (context) => {
    const pres = context.presentation;
    const parts: string[] = [];

    // Force-hydrate the presentation & slides so this works with no selection.
    pres.load("slides");
    await context.sync();

    const slides = pres.slides;
    slides.load("items");
    await context.sync();

    // --- helper to walk shapes recursively ---
    const walkShapes = async (scoped: PowerPoint.ShapeScopedCollection) => {
      scoped.load("items/type");
      await context.sync();

      const frames: PowerPoint.TextFrame[] = [];
      const tables: PowerPoint.Table[] = [];
      const recurse: PowerPoint.ShapeScopedCollection[] = [];

      for (const shape of scoped.items) {
        if (shape.type === PowerPoint.ShapeType.group) {
          recurse.push(shape.group.shapes);
        } else if (shape.type === PowerPoint.ShapeType.table) {
          const tbl = shape.getTable();
          tbl.load("values,rowCount,columnCount");
          tables.push(tbl);
        } else {
          const tf = shape.getTextFrameOrNullObject();
          tf.load("hasText,textRange/text");
          frames.push(tf);
        }
      }
      await context.sync();

      for (const tf of frames) {
        if (!tf.isNullObject && tf.hasText && tf.textRange && typeof tf.textRange.text === "string") {
          const t = (tf.textRange.text || "").trim();
          if (t) parts.push(t);
        }
      }

      for (const tb of tables) {
        for (let r = 0; r < tb.rowCount; r++) {
          for (let c = 0; c < tb.columnCount; c++) {
            const t = (tb.values[r][c] ?? "").toString().trim();
            if (t) parts.push(t);
          }
        }
      }

      for (const inner of recurse) {
        await walkShapes(inner);
      }
    };
    // --- end helper ---

    // Walk each slide (explicitly load shapes to avoid lazy-hydration issues)
    for (const slide of slides.items) {
      slide.load("shapes");
      await context.sync();

      await walkShapes(slide.shapes);

      // Notes page (guarded: not on all clients)
      const notesPage = (slide as any).notesPage;
      if (notesPage?.shapes) {
        await walkShapes(notesPage.shapes);
      }
    }

    return parts.join("\n\n");
  });
}
