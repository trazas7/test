// ppt-selected-table-dom.ts
// Minimal, browser-safe: unzipit + DOMParser (no Node polyfills).

import { unzip } from "unzipit";

/* ======================= Public API ======================= */

export async function getPptText(): Promise<string> {
  return PowerPoint.run(async (ctx) => {
    // 1) highlighted text (fast path)
    const sel = ctx.presentation.getSelectedTextRangeOrNullObject();
    await ctx.sync();
    if (!sel.isNullObject) {
      sel.load("text"); await ctx.sync();
      const t = sel.text?.trim(); if (t) return t;
    }

    // 2) selected shapes
    const ss = ctx.presentation.getSelectedShapes(); ss.load("items"); await ctx.sync();
    if (ss.items.length === 0) return "Select a textbox or a table.";

    ss.items.forEach(s => s.load("type,name,left,top,width,height"));
    await ctx.sync();

    // 2a) TextBox → return text
    for (const s of ss.items as any[]) {
      if (s.type === "TextBox") {
        try {
          s.load("textFrame/textRange/text"); await ctx.sync();
          const txt = s?.textFrame?.textRange?.text?.trim();
          if (txt) return txt;
        } catch {/* ignore */}
      }
    }

    // 2b) Table → parse PPTX and return only the selected table (TSV)
    const tShape = (ss.items as any[]).find(s => s.type === "Table");
    if (!tShape) return "Select a table, then try again.";

    const target = toEMUBox({
      left: Number(tShape.left),
      top: Number(tShape.top),
      width: Number(tShape.width),
      height: Number(tShape.height),
    });
    const selectedName = norm(String(tShape.name ?? ""));

    // 3) pptx → zip → slides → tables
    const zipBuf = await getCompressedFile();
    const { entries } = await unzip(zipBuf);
    const slidePaths = Object.keys(entries)
      .filter(p => /^ppt\/slides\/slide\d+\.xml$/.test(p))
      .sort((a,b)=> slideNo(a)-slideNo(b));

    const all: TableInfo[] = [];
    for (const path of slidePaths) {
      const slide = slideNo(path);
      const xml = await entries[path].text();
      all.push(...extractTablesFromSlideXML(xml, slide));
    }
    if (!all.length) return "No tables found in the presentation.";

    // 4) rank by geometry + small name tie-breaker
    const ranked = all.map(t => {
      const g = geomScore(target, t.geom);
      const pen = norm(t.name) === selectedName ? 0 : NAME_PENALTY;
      return { ...t, score: g + pen, g, pen };
    }).sort((a,b)=> a.score - b.score);

    // optional: enforce a clear margin between #1 and #2
    const best = ranked[0], second = ranked[1];
    if (second && best.score + AMBIGUITY_MARGIN >= second.score) {
      return "Ambiguous selection (two tables look the same).\n" +
             ranked.slice(0,5).map((r,i)=>`${i+1}. score=${fix(r.score)} slide=${r.slideNo} name=${r.name}`).join("\n");
    }
    return best.tsv;
  });
}

/* ======================= Config & Types ======================= */

const EMU_PER_PT = 12700;
const NAME_PENALTY = 0.05;      // prefer same name when geometry ties
const AMBIGUITY_MARGIN = 0.02;  // require clear gap between #1 and #2

type EMUBox = { x: number; y: number; cx: number; cy: number };
type TableInfo = { slideNo: number; name: string; geom: EMUBox; tsv: string };

/* ======================= Slide XML → Tables ======================= */

function extractTablesFromSlideXML(xml: string, slideNo: number): TableInfo[] {
  const doc = new DOMParser().parseFromString(xml, "application/xml");
  // Get all graphicFrames (tables live inside)
  const frames = Array.from(doc.getElementsByTagNameNS("*", "graphicFrame"));
  const out: TableInfo[] = [];

  for (const gf of frames) {
    const nv = firstChildLocal(gf, "nvGraphicFramePr");
    const cNvPr = nv ? firstChildLocal(nv, "cNvPr") : null;
    const name = (cNvPr?.getAttribute("name") ?? "").toString();

    const xfrm = firstChildLocal(gf, "xfrm");
    const off  = xfrm ? firstChildLocal(xfrm, "off") : null;
    const ext  = xfrm ? firstChildLocal(xfrm, "ext") : null;

    const graphic = firstChildLocal(gf, "graphic");
    const gData   = graphic ? firstChildLocal(graphic, "graphicData") : null;
    const tbl     = gData ? firstChildLocal(gData, "tbl") : null;

    if (!off || !ext || !tbl) continue;

    const geom: EMUBox = {
      x: toNum(off.getAttribute("x")),
      y: toNum(off.getAttribute("y")),
      cx: toNum(ext.getAttribute("cx")),
      cy: toNum(ext.getAttribute("cy")),
    };

    const tsv = tableElementToTSV(tbl);
    out.push({ slideNo, name, geom, tsv });
  }

  return out;
}

/* ======================= TSV extraction ======================= */

function tableElementToTSV(tblEl: Element): string {
  const rows = Array.from(tblEl.getElementsByTagNameNS("*", "tr"));
  const lines: string[] = [];

  for (const tr of rows) {
    const cells = Array.from(tr.getElementsByTagNameNS("*", "tc"));
    const vals = cells.map(tc => getCellText(tc));
    // trim trailing empties
    let end = vals.length;
    while (end > 0 && (!vals[end - 1] || !vals[end - 1].trim())) end--;
    lines.push(vals.slice(0, end).join("\t"));
  }
  while (lines.length && !lines[lines.length - 1].trim()) lines.pop();
  return lines.join("\n");
}

function getCellText(tc: Element): string {
  // collect a:t (text) and a:br (line breaks)
  const walker = tc.ownerDocument!.createTreeWalker(
    tc,
    NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT
  );
  let out = "";
  let n: Node | null = walker.nextNode();
  while (n) {
    if (n.nodeType === Node.ELEMENT_NODE) {
      const el = n as Element;
      if (el.localName === "t") out += el.textContent ?? "";
      else if (el.localName === "br") out += "\n";
    }
    n = walker.nextNode();
  }
  return (out || "").replace(/\s+\n/g, "\n").replace(/\n{3,}/g, "\n\n").trim();
}

/* ======================= Ranking helpers ======================= */

function geomScore(a: EMUBox, b: EMUBox): number {
  const dx = Math.abs(a.x - b.x)  / (b.cx || 1);
  const dy = Math.abs(a.y - b.y)  / (b.cy || 1);
  const dw = Math.abs(a.cx - b.cx)/ (b.cx || 1);
  const dh = Math.abs(a.cy - b.cy)/ (b.cy || 1);
  return (dx + dy + dw + dh) / 4;
}

/* ======================= Office file (compressed) ======================= */

async function getCompressedFile(): Promise<ArrayBuffer> {
  const file = await new Promise<Office.File>((res,rej)=>{
    Office.context.document.getFileAsync(Office.FileType.Compressed, r =>
      r.status===Office.AsyncResultStatus.Succeeded ? res(r.value) : rej(r.error)
    );
  });
  try {
    const parts: Uint8Array[] = [];
    for (let i=0;i<file.sliceCount;i++){
      const r = await new Promise<Office.AsyncResult<Office.Slice>>((res,rej)=>{
        file.getSliceAsync(i, s => s.status===Office.AsyncResultStatus.Succeeded ? res(s) : rej(s.error));
      });
      parts.push(new Uint8Array(r.value.data as number[]));
    }
    const total = parts.reduce((s,p)=>s+p.length,0);
    const buf = new Uint8Array(total); let off=0; for (const p of parts){ buf.set(p,off); off+=p.length; }
    return buf.buffer;
  } finally { file.closeAsync(()=>{}); }
}

/* ======================= Tiny utilities ======================= */

function firstChildLocal(parent: Element, local: string): Element | null {
  for (let i = 0; i < parent.childNodes.length; i++) {
    const n = parent.childNodes[i];
    if (n.nodeType === Node.ELEMENT_NODE && (n as Element).localName === local) {
      return n as Element;
    }
  }
  return null;
}

function toEMUBox(pts:{left:number;top:number;width:number;height:number}): EMUBox {
  return {
    x: Math.round(pts.left   * EMU_PER_PT),
    y: Math.round(pts.top    * EMU_PER_PT),
    cx: Math.round(pts.width * EMU_PER_PT),
    cy: Math.round(pts.height* EMU_PER_PT),
  };
}

const norm = (s:string)=> s.trim().replace(/\s+/g," ").toLowerCase();
const slideNo = (p:string)=> parseInt(p.match(/slide(\d+)\.xml/)![1], 10);
const toNum = (v:any)=> Number.isFinite(+v) ? +v : 0;
const fix = (x:number)=> (Math.round(x*10000)/10000).toFixed(4);