export async function getPptSelectedOrAllText(includeNotes: boolean = false): Promise<string> {
  return PowerPoint.run(async (context) => {
    const t0 = Date.now();
    const log = (...a: any[]) => console.log("[getPptSelectedOrAllText]", ...a);

    // 1) explicit text selection
    const selText = context.presentation.getSelectedTextRangeOrNullObject();
    await context.sync();
    if (!selText.isNullObject) {
      selText.load("text");
      await context.sync();
      const t = (selText.text ?? "").trim();
      if (t) {
        log("Returning explicit selection", { length: t.length });
        return t;
      }
    }

    // 2) selected shapes (fallback to deck if empty)
    const selectedShapes = context.presentation.getSelectedShapes();
    selectedShapes.load("items/id,name,type");
    await context.sync();

    if (selectedShapes.items.length) {
      log("No text selection; reading selected shapes", { count: selectedShapes.items.length });
      const partsSel: string[] = [];
      await collectFromShapes(selectedShapes, partsSel, context, log, "selection");
      const fromSelection = partsSel.join("\n\n").trim();
      log("Selected shapes text length", fromSelection.length);
      if (fromSelection) return fromSelection;
      log("No text extracted from selection; falling back to whole deck");
    } else {
      log("Nothing selected; walking entire presentation");
    }

    // 3) whole presentation
    const slides = context.presentation.slides;
    slides.load("items/id,index,name");
    await context.sync();

    const all: string[] = [];
    for (const slide of slides.items) {
      log("Visiting slide", { index: slide.index, id: slide.id, name: slide.name });
      const slideParts: string[] = [
        `# Slide ${slide.index + 1}${slide.name ? ` â€” ${slide.name}` : ""}`,
      ];

      slide.shapes.load("items/id,name,type");
      await context.sync();
      await collectFromShapes(slide.shapes, slideParts, context, log, "slide");

      if (includeNotes) {
        try {
          const notesPage = (slide as any).notesPage;
          if (notesPage) {
            notesPage.shapes.load("items/id,name,type");
            await context.sync();
            const notesParts: string[] = [];
            await collectFromShapes(notesPage.shapes, notesParts, context, log, "notes");
            if (notesParts.length) {
              slideParts.push("Notes:");
              slideParts.push(notesParts.join("\n"));
            }
          }
        } catch (e) {
          log("Reading notes failed:", e);
        }
      }

      all.push(slideParts.join("\n"));
    }

    const result = all.join("\n\n----\n\n");
    log("Finished deck walk", {
      slides: slides.items.length,
      length: result.length,
      ms: Date.now() - t0,
    });
    return result;
  });
}

async function collectFromShapes(
  scoped: PowerPoint.ShapeCollection | PowerPoint.ShapeScopedCollection,
  parts: string[],
  ctx: PowerPoint.RequestContext,
  log: (...args: any[]) => void,
  where: "selection" | "slide" | "notes"
) {
  scoped.load("items/id,name,type,group,table,textFrame/hasText,textFrame/textRange/text");
  await ctx.sync();

  const tableJobs: { id: string; tbl: PowerPoint.Table }[] = [];

  for (const shape of (scoped as any).items as PowerPoint.Shape[]) {
    log("Shape", { where, id: shape.id, name: shape.name, type: shape.shapeType });

    if (shape.shapeType === PowerPoint.ShapeType.group) {
      try {
        await collectFromShapes(shape.group.shapes, parts, ctx, log, where);
      } catch (e) {
        log("Group read failed", { id: shape.id, e });
      }
      continue;
    }

    if (shape.shapeType === PowerPoint.ShapeType.table) {
      try { tableJobs.push({ id: shape.id as any, tbl: shape.getTable() }); }
      catch (e) { log("getTable() failed", { id: shape.id, e }); }
      continue;
    }

    try {
      const tf = shape.getTextFrameOrNullObject();
      tf.load("hasText,textRange/text");
      await ctx.sync();
      if (!(tf as any).isNullObject && tf.hasText && tf.textRange && typeof tf.textRange.text === "string") {
        const t = (tf.textRange.text || "").trim();
        if (t) { parts.push(t); log("TextFrame extracted", { where, id: shape.id, len: t.length }); }
        else   { log("TextFrame empty",     { where, id: shape.id }); }
      }
    } catch (e) {
      log("TextFrame read failed", { id: shape.id, e });
    }
  }

  if (tableJobs.length) {
    try {
      for (const j of tableJobs) j.tbl.load("values,rowCount,columnCount");
      await ctx.sync();
      for (const { id, tbl } of tableJobs) {
        let pushed = false;
        try {
          if (Array.isArray((tbl as any).values)) {
            const t = (tbl as any).values.map((row: string[]) => row.join("\t")).join("\n").trim();
            if (t) { parts.push(t); pushed = true; log("Table(values) extracted", { where, id, rows: tbl.rowCount, cols: tbl.columnCount }); }
          }
        } catch {}
        if (!pushed && typeof tbl.rowCount === "number" && typeof tbl.columnCount === "number") {
          const out: string[] = [];
          for (let r = 0; r < tbl.rowCount; r++) {
            const row: string[] = [];
            for (let c = 0; c < tbl.columnCount; c++) {
              const cell = tbl.getCellOrNullObject(r, c);
              cell.load("text");
              await ctx.sync();
              row.push((cell.text ?? "").trim());
            }
            out.push(row.join("\t"));
          }
          const t = out.join("\n").trim();
          if (t) { parts.push(t); log("Table(cell-by-cell) extracted", { where, id, rows: tbl.rowCount, cols: tbl.columnCount }); }
          else   { log("Table empty", { where, id }); }
        }
      }
    } catch (e) {
      log("Table read failed", e);
    }
  }
}
