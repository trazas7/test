export async function getPptSelectedTextOrShape(): Promise<string> {
  return PowerPoint.run(async (ctx) => {
    // 1) Try highlighted text first
    const sel = ctx.presentation.getSelectedTextRangeOrNullObject();
    await ctx.sync();
    
    if (!sel.isNullObject) {
      sel.load("text");
      await ctx.sync();
      return (sel.text ?? "").trim();
    }

    // 2) Fallback: check if a shape (including table) is selected
    const shapes = ctx.presentation.getSelectedShapes();
    shapes.load("items");
    await ctx.sync();

    if (shapes.items.length) {
      for (const shape of shapes.items) {
        // Load shape properties to determine type
        shape.load("type,table");
        await ctx.sync();

        // Handle table shapes
        if (shape.type === "Table" && shape.table) {
          return await extractTableText(shape.table, ctx);
        }
        
        // Handle text shapes (your existing logic)
        if (shape.type === "GeometricShape" || shape.type === "TextBox") {
          shape.load("textFrame/hasText,textFrame/textRange/text");
          await ctx.sync();
          
          if (shape.textFrame?.hasText && shape.textFrame?.textRange?.text) {
            return shape.textFrame.textRange.text.trim();
          }
        }
      }
    }

    return "";
  });
}

async function extractTableText(table: PowerPoint.Table, ctx: PowerPoint.RequestContext): Promise<string> {
  // Load table dimensions
  table.load("rowCount,columnCount");
  await ctx.sync();

  let tableText = "";
  
  // Iterate through all cells
  for (let row = 0; row < table.rowCount; row++) {
    let rowText = "";
    
    for (let col = 0; col < table.columnCount; col++) {
      const cell = table.getCell(row, col);
      cell.load("textFrame/textRange/text");
      await ctx.sync();
      
      const cellText = cell.textFrame?.textRange?.text?.trim() || "";
      rowText += cellText;
      
      // Add tab separator between columns (except last column)
      if (col < table.columnCount - 1) {
        rowText += "\t";
      }
    }
    
    tableText += rowText;
    
    // Add newline between rows (except last row)
    if (row < table.rowCount - 1) {
      tableText += "\n";
    }
  }
  
  return tableText;
}

// Alternative version that extracts only selected cells if available
async function extractSelectedTableCells(table: PowerPoint.Table, ctx: PowerPoint.RequestContext): Promise<string> {
  try {
    // Try to get selected table range (this might not be available in all Office versions)
    const selectedRange = table.getSelectedRange();
    selectedRange.load("rowCount,columnCount,rowIndex,columnIndex");
    await ctx.sync();
    
    let selectedText = "";
    
    for (let row = 0; row < selectedRange.rowCount; row++) {
      let rowText = "";
      
      for (let col = 0; col < selectedRange.columnCount; col++) {
        const actualRow = selectedRange.rowIndex + row;
        const actualCol = selectedRange.columnIndex + col;
        
        const cell = table.getCell(actualRow, actualCol);
        cell.load("textFrame/textRange/text");
        await ctx.sync();
        
        const cellText = cell.textFrame?.textRange?.text?.trim() || "";
        rowText += cellText;
        
        if (col < selectedRange.columnCount - 1) {
          rowText += "\t";
        }
      }
      
      selectedText += rowText;
      if (row < selectedRange.rowCount - 1) {
        selectedText += "\n";
      }
    }
    
    return selectedText;
  } catch (error) {
    // Fallback to extracting entire table if selected range is not available
    return await extractTableText(table, ctx);
  }
}
