/**
 * Returns selected text if present; otherwise returns ALL textual content
 * from the entire deck (slides, groups, text boxes, placeholders, tables).
 * Pass includeNotes=true to also collect speaker notes text.
 *
 * Lots of console logs are included to help debug in DevTools.
 */
export async function getPptSelectedOrAllText(includeNotes: boolean = false): Promise<string> {
  return PowerPoint.run(async (context) => {
    const t0 = Date.now();
    const log = (...a: any[]) => console.log("[getPptSelectedOrAllText]", ...a);

    // ── 1) explicit text selection?
    const selText = context.presentation.getSelectedTextRangeOrNullObject();
    await context.sync();
    if (!selText.isNullObject) {
      selText.load("text");
      await context.sync();
      const t = (selText.text ?? "").trim();
      if (t) {
        log("Returning explicit selection", { length: t.length });
        return t;
      }
    }

    // ── 2) read selected shapes (if any) and if that produces nothing, fall back to whole deck
    const selectedShapes = context.presentation.getSelectedShapes();
    selectedShapes.load("items/id,name,type");
    await context.sync();

    if (selectedShapes.items.length) {
      log("No text selection; reading selected shapes", { count: selectedShapes.items.length });
      const partsSel: string[] = [];
      await collectFromShapes(selectedShapes, partsSel, context, log, "selection");
      const fromSelection = partsSel.join("\n\n").trim();
      log("Selected shapes text length", fromSelection.length);
      if (fromSelection) return fromSelection;
      log("No text extracted from selection; falling back to whole deck");
    } else {
      log("Nothing selected; walking entire presentation");
    }

    // ── 3) whole presentation
    const slides = context.presentation.slides;
    slides.load("items/id,index,name");
    await context.sync();

    const all: string[] = [];
    for (const slide of slides.items) {
      log("Visiting slide", { index: slide.index, id: slide.id, name: slide.name });
      const slideParts: string[] = [
        `# Slide ${slide.index + 1}${slide.name ? ` — ${slide.name}` : ""}`,
      ];

      // Slide shapes
      slide.shapes.load("items/id,name,type");
      await context.sync();
      await collectFromShapes(slide.shapes, slideParts, context, log, "slide");

      // Speaker notes (optional)
      if (includeNotes) {
        try {
          const notesPage = (slide as any).notesPage; // notesPage isn't in older typings
          if (notesPage) {
            notesPage.shapes.load("items/id,name,type");
            await context.sync();
            const notesParts: string[] = [];
            await collectFromShapes(notesPage.shapes, notesParts, context, log, "notes");
            if (notesParts.length) {
              slideParts.push("Notes:");
              slideParts.push(notesParts.join("\n"));
            }
          }
        } catch (e) {
          log("Reading notes failed:", e);
        }
      }

      all.push(slideParts.join("\n"));
    }

    const result = all.join("\n\n----\n\n");
    log("Finished deck walk", {
      slides: slides.items.length,
      length: result.length,
      ms: Date.now() - t0,
    });
    return result;
  });
}

/**
 * Recursively collects text from any Shape collection (scoped or not).
 * Handles: text frames, tables (values[][] or cell-by-cell), and groups.
 * Emits verbose logs for troubleshooting.
 */
async function collectFromShapes(
  scoped: PowerPoint.ShapeCollection | PowerPoint.ShapeScopedCollection,
  parts: string[],
  ctx: PowerPoint.RequestContext,
  log: (...args: any[]) => void,
  where: "selection" | "slide" | "notes"
) {
  // Load everything we will query BEFORE reading it
  scoped.load("items/id,name,type,group,table,textFrame/hasText,textFrame/textRange/text");
  await ctx.sync();

  // Batch: for tables we’ll load values after we know which are tables
  const tablesToRead: { shapeId: string; tbl: PowerPoint.Table }[] = [];

  for (const shape of (scoped as any).items as PowerPoint.Shape[]) {
    log("Shape", { where, id: shape.id, name: shape.name, type: shape.shapeType });

    // group → recurse
    if (shape.shapeType === PowerPoint.ShapeType.group) {
      try {
        await collectFromShapes(shape.group.shapes, parts, ctx, log, where);
      } catch (e) {
        log("Group read failed", { id: shape.id, e });
      }
      continue;
    }

    // table → collect to read (we batch load values below)
    if (shape.shapeType === PowerPoint.ShapeType.table) {
      try {
        const tbl = shape.getTable();
        tablesToRead.push({ shapeId: shape.id as any, tbl });
      } catch (e) {
        log("getTable() failed", { id: shape.id, e });
      }
      continue;
    }

    // text frame
    try {
      const tf = shape.getTextFrameOrNullObject();
      tf.load("hasText,textRange/text");
      await ctx.sync();
      if (!(tf as any).isNullObject && tf.hasText && tf.textRange && typeof tf.textRange.text === "string") {
        const t = (tf.textRange.text || "").trim();
        if (t) {
          parts.push(t);
          log("TextFrame extracted", { where, id: shape.id, len: t.length });
        } else {
          log("TextFrame empty", { where, id: shape.id });
        }
      }
    } catch (e) {
      log("TextFrame read failed", { id: shape.id, e });
    }
  }

  // tables: prefer values[][] if provided; otherwise fall back to cell-by-cell
  if (tablesToRead.length) {
    // First try to get values in one batch
    try {
      for (const t of tablesToRead) t.tbl.load("values,rowCount,columnCount");
      await ctx.sync();

      for (const { shapeId, tbl } of tablesToRead) {
        let pushed = false;
        try {
          if (Array.isArray((tbl as any).values)) {
            const t = (tbl as any).values.map((row: string[]) => row.join("\t")).join("\n").trim();
            if (t) {
              parts.push(t);
              pushed = true;
              log("Table(values) extracted", { where, id: shapeId, rows: tbl.rowCount, cols: tbl.columnCount });
            }
          }
        } catch { /* fall through to cell-by-cell */ }

        if (!pushed && typeof tbl.rowCount === "number" && typeof tbl.columnCount === "number") {
          const rowsOut: string[] = [];
          for (let r = 0; r < tbl.rowCount; r++) {
            const rowVals: string[] = [];
            for (let c = 0; c < tbl.columnCount; c++) {
              const cell = tbl.getCellOrNullObject(r, c);
              cell.load("text");
              await ctx.sync();
              rowVals.push((cell.text ?? "").trim());
            }
            rowsOut.push(rowVals.join("\t"));
          }
          const t = rowsOut.join("\n").trim();
          if (t) {
            parts.push(t);
            log("Table(cell-by-cell) extracted", { where, id: shapeId, rows: tbl.rowCount, cols: tbl.columnCount });
          } else {
            log("Table empty", { where, id: shapeId });
          }
        }
      }
    } catch (e) {
      log("Table read failed", e);
    }
  }
}
