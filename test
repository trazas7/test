/**
 * Returns ALL text from the presentation (slides + notes if available).
 * Works even when nothing is selected.
 */
export async function getWholeDeckText(): Promise<string> {
  return PowerPoint.run(async (context) => {
    const pres = context.presentation;
    const parts: string[] = [];

    // --- helpers -------------------------------------------------------------

    // Walk a ShapeCollection (used on slides, groups, notes pages)
    const walkShapeCollection = async (coll: PowerPoint.ShapeCollection) => {
      coll.load("items/type");
      await context.sync();

      const frames: PowerPoint.TextFrame[] = [];
      const tables: PowerPoint.Table[] = [];
      const groups: PowerPoint.ShapeCollection[] = [];

      for (const shape of coll.items) {
        if (shape.type === PowerPoint.ShapeType.group) {
          groups.push(shape.group.shapes); // <â€” ShapeCollection
        } else if (shape.type === PowerPoint.ShapeType.table) {
          const tbl = shape.getTable();
          tbl.load("values,rowCount,columnCount");
          tables.push(tbl);
        } else {
          const tf = shape.getTextFrameOrNullObject();
          tf.load("hasText,textRange/text");
          frames.push(tf);
        }
      }
      await context.sync();

      // collect text frames
      for (const tf of frames) {
        if (!tf.isNullObject && tf.hasText && tf.textRange && typeof tf.textRange.text === "string") {
          const t = (tf.textRange.text || "").trim();
          if (t) parts.push(t);
        }
      }

      // collect table cells
      for (const tb of tables) {
        for (let r = 0; r < tb.rowCount; r++) {
          for (let c = 0; c < tb.columnCount; c++) {
            const t = (tb.values[r][c] ?? "").toString().trim();
            if (t) parts.push(t);
          }
        }
      }

      // recurse into grouped shapes
      for (const g of groups) {
        await walkShapeCollection(g);
      }
    };

    // --- hydrate deck & iterate slides --------------------------------------

    pres.load("slides");
    await context.sync();

    const slides = pres.slides;
    slides.load("items");
    await context.sync();

    for (const slide of slides.items) {
      slide.shapes.load("items/type");
      await context.sync();
      await walkShapeCollection(slide.shapes);

      // Notes page (guarded; not in all clients)
      const notesPage = (slide as any).notesPage;
      if (notesPage?.shapes) {
        await walkShapeCollection(notesPage.shapes);
      }
    }

    return parts.join("\n\n");
  });
}
