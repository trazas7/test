async function collectFromShapes(
  scoped: PowerPoint.ShapeCollection | PowerPoint.ShapeScopedCollection,
  parts: string[],
  ctx: PowerPoint.RequestContext,
  logFn: (...args: any[]) => void,
  where: string
) {
  // ðŸ‘‡ Load type, name, and text info before sync
  scoped.load("items/type,name,textFrame/hasText,textFrame/textRange/text");
  await ctx.sync();

  for (const shape of (scoped as any).items as PowerPoint.Shape[]) {
    logFn("Shape", {
      where,
      id: shape.id,
      name: shape.name,
      type: shape.shapeType,
      hasText: shape.textFrame?.hasText,
    });

    // âœ… If itâ€™s a group, recurse
    if (shape.shapeType === PowerPoint.ShapeType.group) {
      await collectFromShapes(shape.group.shapes, parts, ctx, logFn, where);
    }

    // âœ… If itâ€™s a table
    if (shape.shapeType === PowerPoint.ShapeType.table) {
      const tbl = shape.getTable();
      tbl.load("values");
      await ctx.sync();
      const tblText = tbl.values.map(row => row.join("\t")).join("\n").trim();
      if (tblText) {
        parts.push(tblText);
      }
    }

    // âœ… If it has text
    if (shape.textFrame && shape.textFrame.hasText && shape.textFrame.textRange) {
      const text = (shape.textFrame.textRange.text ?? "").trim();
      if (text) {
        logFn("Extracted text:", text);
        parts.push(text);
      }
    }
  }
}
