function extractTextShapes(xml: string, slideNo: number, rels: Map<string, string>): TextShapeInfo[] {
  const doc = new DOMParser().parseFromString(xml, "application/xml");
  const spTree = Array.from(doc.getElementsByTagNameNS("*", "spTree"));

  const found: TextShapeInfo[] = [];

  for (const root of spTree) {
    walkShapes(root, slideNo, rels, found);
  }
  return found;
}

/** Recursively walks shapes inside <p:spTree> or <p:grpSp> */
function walkShapes(node: Element, slideNo: number, rels: Map<string, string>, out: TextShapeInfo[]) {
  const children = Array.from(node.childNodes).filter(n => n.nodeType === Node.ELEMENT_NODE) as Element[];

  for (const el of children) {
    const tag = el.localName;

    if (tag === "sp") {
      const txBody = first(el, "txBody");
      if (!txBody) continue;

      const nvSpPr = first(el, "nvSpPr");
      const cNvPr = nvSpPr && first(nvSpPr, "cNvPr");
      const name = (cNvPr?.getAttribute("name") ?? "").toString();

      const xfrm = first(el, "xfrm");
      const off = xfrm && first(xfrm, "off");
      const ext = xfrm && first(xfrm, "ext");
      if (!off || !ext) continue;

      const geom: EMUBox = {
        x: num(off.getAttribute("x")),
        y: num(off.getAttribute("y")),
        cx: num(ext.getAttribute("cx")),
        cy: num(ext.getAttribute("cy")),
      };

      // Whole-shape hyperlink
      let shapeUrl: string | null = null;
      const shpHL = cNvPr && first(cNvPr, "hlinkClick");
      const shpRel =
        shpHL?.getAttributeNS("http://schemas.openxmlformats.org/officeDocument/2006/relationships", "id") ||
        shpHL?.getAttribute("r:id");
      if (shpRel) shapeUrl = rels.get(shpRel) ?? null;

      const text = readTextBodyWithLinks(txBody, rels, shapeUrl);
      if (text.trim()) out.push({ slideNo, name, geom, text });
    }

    // If this is a group, recurse deeper
    if (tag === "grpSp") {
      const nestedTree = first(el, "spTree");
      if (nestedTree) {
        walkShapes(nestedTree, slideNo, rels, out);
      }
    }
  }
}