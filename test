async function getPptSelectedOrFullText(task: any): Promise<string> {
  return await PowerPoint.run(async (ctx) => {
    // 1) Try shapes first — don’t touch table internals
    const selShapes = ctx.presentation.getSelectedShapes();
    selShapes.load("items");
    await ctx.sync();
    console.log("[DBG] selectedShapes.count:", selShapes.items.length);

    selShapes.items.forEach(s => s.load("id,name,type"));
    await ctx.sync();

    for (const s of selShapes.items as any[]) {
      console.log("[DBG] visiting shape", { id: s.id, name: s.name, type: s.type });

      if (s.type === "Table") {
        console.log("[DBG] Table selected — API cannot read cells unless caret is inside a cell.");
        showInfo("Click inside a table cell (text cursor visible) and run again.");
        // Skip; don't try s.table.rows/columns — it will be undefined on many builds.
        continue;
      }

      // Text boxes/placeholders
      try {
        s.load("textFrame/hasText,textFrame/textRange/text");
        await ctx.sync();
        if (s.textFrame?.hasText && s.textFrame?.textRange?.text) {
          const t = (s.textFrame.textRange.text || "").trim();
          if (t) return t;
        }
      } catch (e) {
        console.warn("[DBG] loading textFrame failed:", e);
      }

      // Groups? (Optional: recurse into groupItems safely by first loading id/name/type of children)
    }

    // 2) If nothing from shapes, try a pure text selection (works when caret is inside table cell)
    try {
      const selRange = ctx.presentation.getSelectedTextRange();
      selRange.load("text");
      await ctx.sync();
      const txt = (selRange.text ?? "").trim();
      console.log("[DBG] selectedTextRange:", JSON.stringify(txt));
      if (txt) return txt;
    } catch (e) {
      console.warn("[DBG] getSelectedTextRange threw (table selected but no caret):", e);
    }

    // 3) Fallback (your existing method)
    if (!task.shouldSelectText && task.name !== "AD_HOC") {
      console.log("[DBG] Falling back to collectAllSlidesText");
      try { return await collectAllSlidesText(ctx); }
      catch (e) { console.warn("[DBG] collectAllSlidesText failed:", e); }
    }

    console.log("[DBG] No usable selection.");
    return "";
  });
}