// Replace with your own UI toast if you have one.
function notify(msg: string) {
  console.log("[INFO]", msg);
}

async function getPptSelectedOrFullText(task: any): Promise<string> {
  return await PowerPoint.run(async (ctx) => {
    // 1) Shapes first — detect tables and bail with a hint
    const selShapes = ctx.presentation.getSelectedShapes();
    selShapes.load("items");
    await ctx.sync();
    console.log("[DBG] selectedShapes.count:", selShapes.items.length);

    selShapes.items.forEach(s => s.load("id,name,type"));
    await ctx.sync();

    for (const s of selShapes.items as any[]) {
      console.log("[DBG] visiting shape", { id: s.id, name: s.name, type: s.type });

      if (s.type === "Table") {
        // Don’t touch s.table.* — it's undefined on many builds.
        notify("Click **inside** a table cell so the text cursor is blinking, then select the text (or press Ctrl+A to select that cell) and run again.");
        // keep going; maybe user also has a text selection
      } else {
        // Text boxes/placeholders
        try {
          s.load("textFrame/hasText,textFrame/textRange/text");
          await ctx.sync();
          if (s.textFrame?.hasText && s.textFrame?.textRange?.text) {
            const t = (s.textFrame.textRange.text || "").trim();
            if (t) return t;
          }
        } catch (e) {
          console.warn("[DBG] loading textFrame failed:", e);
        }
      }
    }

    // 2) Try a true text selection (works if caret is inside a table cell or textbox)
    try {
      const selRange = ctx.presentation.getSelectedTextRange();
      selRange.load("text");
      await ctx.sync();
      const txt = (selRange.text ?? "").trim();
      console.log("[DBG] selectedTextRange:", JSON.stringify(txt));
      if (txt) return txt;
    } catch (e) {
      console.warn("[DBG] getSelectedTextRange threw (likely table shape selected without caret):", e);
    }

    // 3) Optional fallback
    if (!task.shouldSelectText && task.name !== "AD_HOC") {
      console.log("[DBG] Falling back to collectAllSlidesText");
      try {
        return await collectAllSlidesText(ctx);
      } catch (e) {
        console.warn("[DBG] collectAllSlidesText failed:", e);
      }
    }

    console.log("[DBG] No usable selection.");
    return "";
  });
}