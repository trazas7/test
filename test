/**
 * ------------ WORD ------------
 */
async function getWordText(task) {
  return Word.run(async (ctx) => {
    const sel = ctx.document.getSelection();
    sel.load("text");
    await ctx.sync();

    const s = (sel.text || "").trim();
    if (s) return s;

    if (!task.shouldSelectText) {
      const body = ctx.document.body;
      body.load("text");
      await ctx.sync();
      return (body.text || "").trim();
    }
    return "";
  });
}

/**
 * ------------ POWERPOINT ------------
 * Selection → shapes (incl. tables) → selected slides → whole deck (if allowed)
 */
async function getPowerPointText(task) {
  return PowerPoint.run(async (ctx) => {
    // 1) direct text selection
    const tr = ctx.presentation.getSelectedTextRange();
    tr.load("text");
    await ctx.sync();
    if (tr.text && tr.text.trim()) return tr.text.trim();

    const has13 = Office.context.requirements.isSetSupported("PowerPointApi", "1.3");
    const has14 = Office.context.requirements.isSetSupported("PowerPointApi", "1.4");

    // 2) selected shapes (covers tables + text frames)
    if (has13) {
      const shapesSel = ctx.presentation.getSelectedShapes();
      const textFromShapes = await collectFromShapeCollection(ctx, shapesSel);
      if (textFromShapes) return textFromShapes;
    }

    // 3) selected slides (works when the user simply clicks a slide)
    if (has14 && typeof ctx.presentation.getSelectedSlides === "function") {
      const selSlides = ctx.presentation.getSelectedSlides();
      selSlides.load("items");
      await ctx.sync();
      if (selSlides.items.length) {
        const textFromSelSlides = await collectFromSlides(ctx, selSlides.items);
        if (textFromSelSlides) return textFromSelSlides;
      }
    }

    // 4) whole deck only when selection not required
    if (!task.shouldSelectText && has13) {
      const slides = ctx.presentation.slides;
      slides.load("items");
      await ctx.sync();
      return await collectFromSlides(ctx, slides.items);
    }

    return "";
  });
}

/**
 * ---- helpers: safe traversals that avoid InvalidArgument ----
 */

// Selected shapes or any ShapeCollection → gather text & table cell text
async function collectFromShapeCollection(ctx, shapeCollection) {
  shapeCollection.load("items");
  await ctx.sync();
  if (!shapeCollection.items.length) return "";

  // discover capabilities
  shapeCollection.items.forEach(sh => safeLoad(sh, "textFrame,table"));
  await ctx.sync();

  // prep deeper loads
  shapeCollection.items.forEach(sh => {
    if (sh.textFrame) safeLoad(sh.textFrame, "hasText");
    if (sh.table) safeLoad(sh.table, "rows");
  });
  await ctx.sync();

  // rows → cells
  shapeCollection.items.forEach(sh => {
    if (sh.table && sh.table.rows) {
      sh.table.rows.load("items");
    }
  });
  await ctx.sync();

  shapeCollection.items.forEach(sh => {
    if (sh.table && sh.table.rows && sh.table.rows.items) {
      sh.table.rows.items.forEach(r => safeLoad(r, "cells"));
    }
  });
  await ctx.sync();

  shapeCollection.items.forEach(sh => {
    if (sh.table && sh.table.rows && sh.table.rows.items) {
      sh.table.rows.items.forEach(r => {
        r.cells.load("items");
      });
    }
  });
  await ctx.sync();

  // now safely load text
  shapeCollection.items.forEach(sh => {
    if (sh.textFrame && sh.textFrame.hasText) {
      safeLoad(sh.textFrame.textRange, "text");
    }
    if (sh.table && sh.table.rows && sh.table.rows.items) {
      sh.table.rows.items.forEach(r => {
        r.cells.items.forEach(c => {
          if (c.textFrame) safeLoad(c.textFrame.textRange, "text");
        });
      });
    }
  });
  await ctx.sync();

  // collect
  let out = "";
  for (const sh of shapeCollection.items) {
    if (sh.textFrame && sh.textFrame.hasText) {
      const t = (sh.textFrame.textRange.text || "").trim();
      if (t) out += t + "\n";
    }
    if (sh.table && sh.table.rows && sh.table.rows.items) {
      for (const r of sh.table.rows.items) {
        for (const c of r.cells.items) {
          const t = (c.textFrame && c.textFrame.textRange && c.textFrame.textRange.text || "").trim();
          if (t) out += t + "\n";
        }
      }
    }
  }
  return out.trim();
}

// Slides[] → shapes → text & table cell text
async function collectFromSlides(ctx, slidesArray) {
  if (!slidesArray || !slidesArray.length) return "";

  // load shapes for each slide
  slidesArray.forEach(s => safeLoad(s, "shapes"));
  await ctx.sync();

  slidesArray.forEach(s => {
    if (s.shapes) s.shapes.load("items");
  });
  await ctx.sync();

  // discover per-shape
  slidesArray.forEach(s => {
    if (s.shapes && s.shapes.items) {
      s.shapes.items.forEach(sh => safeLoad(sh, "textFrame,table"));
    }
  });
  await ctx.sync();

  // prep deeper loads
  slidesArray.forEach(s => {
    if (s.shapes && s.shapes.items) {
      s.shapes.items.forEach(sh => {
        if (sh.textFrame) safeLoad(sh.textFrame, "hasText");
        if (sh.table) safeLoad(sh.table, "rows");
      });
    }
  });
  await ctx.sync();

  slidesArray.forEach(s => {
    if (s.shapes) {
      s.shapes.items.forEach(sh => {
        if (sh.table && sh.table.rows) sh.table.rows.load("items");
      });
    }
  });
  await ctx.sync();

  slidesArray.forEach(s => {
    if (s.shapes) {
      s.shapes.items.forEach(sh => {
        if (sh.table && sh.table.rows && s.shapes) {
          sh.table.rows.items.forEach(r => safeLoad(r, "cells"));
        }
      });
    }
  });
  await ctx.sync();

  slidesArray.forEach(s => {
    if (s.shapes) {
      s.shapes.items.forEach(sh => {
        if (sh.table && sh.table.rows) {
          sh.table.rows.items.forEach(r => r.cells.load("items"));
        }
      });
    }
  });
  await ctx.sync();

  slidesArray.forEach(s => {
    if (s.shapes) {
      s.shapes.items.forEach(sh => {
        if (sh.textFrame && sh.textFrame.hasText) {
          safeLoad(sh.textFrame.textRange, "text");
        }
        if (sh.table && sh.table.rows) {
          sh.table.rows.items.forEach(r => {
            r.cells.items.forEach(c => {
              if (c.textFrame) safeLoad(c.textFrame.textRange, "text");
            });
          });
        }
      });
    }
  });
  await ctx.sync();

  // collect
  let out = "";
  for (const s of slidesArray) {
    if (!s.shapes) continue;
    for (const sh of s.shapes.items) {
      if (sh.textFrame && sh.textFrame.hasText) {
        const t = (sh.textFrame.textRange.text || "").trim();
        if (t) out += t + "\n";
      }
      if (sh.table && sh.table.rows) {
        for (const r of sh.table.rows.items) {
          for (const c of r.cells.items) {
            const t = (c.textFrame && c.textFrame.textRange && c.textFrame.textRange.text || "").trim();
            if (t) out += t + "\n";
          }
        }
      }
    }
  }
  return out.trim();
}

// Small guard for property loads that may not exist on older builds/shapes.
function safeLoad(obj, props) {
  try { if (obj && obj.load) obj.load(props); } catch (_) { /* ignore */ }
}

/**
 * ------------ BUTTONS ------------
 */
function setupButtons() {
  for (const buttonId in TASK_CONFIG) {
    const el = document.getElementById(buttonId);
    if (!el) continue;

    el.addEventListener("click", async () => {
      try {
        const task = TASK_CONFIG[buttonId];
        currentTask = task.name;

        let text = "";
        if (Office.context.host === Office.HostType.Word) {
          text = await getWordText(task);
        } else if (Office.context.host === Office.HostType.PowerPoint) {
          text = await getPowerPointText(task);
        } else {
          showMessage("This add-in supports Word and PowerPoint.", "error");
          return;
        }

        if (!text && task.shouldSelectText) {
          showMessage("Select some text, a table, or a slide.", "error");
          return;
        }

        const prompt = text ? (task.prompt ? `${task.prompt}\n${text}` : text) : null;

        showPromptScreen({
          heading: task.heading,
          prompt,
          name: task.name,
          skipPromptReview: task.skipPromptReview
        });
      } catch (err) {
        console.error(err);
        showMessage("Couldn’t read slide content. Try again on a smaller selection.", "error");
      }
    });
  }
}
