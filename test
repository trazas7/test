export async function getAllPptTextOrSelection(): Promise<string> {
  return PowerPoint.run(async (context) => {
    const log = (...args: any[]) => console.log("[ppt-extract]", ...args);

    log("PowerPointApi supported:", {
      ">=1.5": Office.context.requirements.isSetSupported("PowerPointApi", "1.5"),
      ">=1.6": Office.context.requirements.isSetSupported("PowerPointApi", "1.6"),
    });

    // 1Ô∏è‚É£ Try selected text first
    const selectedText = context.presentation.getSelectedTextRangeOrNullObject();
    await context.sync();
    if (!selectedText.isNullObject) {
      selectedText.load("text");
      await context.sync();
      if (selectedText.text?.trim()) {
        log("RETURN selection text", { length: selectedText.text.trim().length });
        return selectedText.text.trim();
      }
    }

    // 2Ô∏è‚É£ Try selected shapes next
    const selectedShapes = context.presentation.getSelectedShapes();
    selectedShapes.load("items/id,name,type");
    await context.sync();
    log("selected-shapes", { count: selectedShapes.items?.length });

    if (selectedShapes.items?.length > 0) {
      const parts: string[] = [];
      await collectTextFromShapes(selectedShapes, parts, context, log, "selected");
      if (parts.length > 0) {
        log("Returning text from selected shapes", { parts: parts.length });
        return parts.join("\n\n");
      }
    }

    // 3Ô∏è‚É£ Fallback: Walk entire deck
    const slides = context.presentation.slides;
    slides.load("items/id,index,name");
    await context.sync();
    log("deck", { slideCount: slides.items.length });

    const deckParts: string[] = [];

    for (const slide of slides.items) {
      log("Processing slide", { index: slide.index, id: slide.id, name: slide.name });
      slide.shapes.load("items/id,name,type");
      await context.sync();
      log("shapes loaded", { slideIndex: slide.index, shapeCount: slide.shapes.items.length });

      const slideParts: string[] = [`# Slide ${slide.index + 1}`];
      await collectTextFromShapes(slide.shapes, slideParts, context, log, `slide:${slide.index}`);
      deckParts.push(slideParts.join("\n"));
    }

    const result = deckParts.join("\n\n----\n\n");
    log("‚úÖ Finished deck text extraction", { length: result.length });
    return result;
  });
}

async function collectTextFromShapes(
  shapes: PowerPoint.ShapeCollection | PowerPoint.ShapeScopedCollection,
  out: string[],
  context: PowerPoint.RequestContext,
  log: (...args: any[]) => void,
  where: string
) {
  shapes.load(
    "items/id,name,type," +
      "items/textFrame/hasText,items/textFrame/textRange/text"
  );
  await context.sync();
  log("collectTextFromShapes", { where, shapeCount: shapes.items.length });

  for (const shape of shapes.items) {
    log("Inspecting shape", { where, id: shape.id, name: shape.name, type: shape.type });

    // üì¶ Try direct textFrame.textRange.text
    try {
      const tf = shape.textFrame;
      if (tf?.textRange?.text && tf.textRange.text.trim()) {
        const text = tf.textRange.text.trim();
        log("‚úÖ Found text", { where, textLength: text.length });
        out.push(text);
        continue;
      }
    } catch (e) {
      log("textFrame direct error", { where, id: shape.id, e });
    }

    // üì¶ Fallback: getTextFrameOrNullObject()
    try {
      const tf2 = shape.getTextFrameOrNullObject();
      tf2.load("hasText,textRange/text");
      await context.sync();
      if (!(tf2 as any).isNullObject && tf2.textRange?.text?.trim()) {
        const text = tf2.textRange.text.trim();
        log("‚úÖ Found fallback text", { where, textLength: text.length });
        out.push(text);
      }
    } catch (e) {
      log("textFrame fallback error", { where, id: shape.id, e });
    }

    // üì¶ Tables
    if (shape.type === PowerPoint.ShapeType.table) {
      try {
        const table = shape.getTable();
        table.load("values,rowCount,columnCount");
        await context.sync();
        if (Array.isArray((table as any).values)) {
          const text = (table as any).values.map((r: string[]) => r.join("\t")).join("\n");
          log("‚úÖ Found table text", { where, textLength: text.length });
          out.push(text.trim());
        }
      } catch (e) {
        log("table error", { where, id: shape.id, e });
      }
    }

    // üì¶ Group fallback
    if (shape.type === PowerPoint.ShapeType.group) {
      try {
        const groupShapes = shape.group.shapes;
        log("‚Ü™Ô∏è Entering group", { where, id: shape.id });
        await collectTextFromShapes(groupShapes, out, context, log, `${where}::group`);
      } catch (e) {
        log("group error", { where, id: shape.id, e });
      }
    }
  }
}
