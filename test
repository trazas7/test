/**
 * Walk the entire presentation and return all text (shapes, groups, tables, optional notes).
 * This version eagerly loads TextFrame on each shape so text boxes & placeholders are captured.
 */
export async function dumpWholeDeckText(opts?: { includeNotes?: boolean }): Promise<string> {
  const includeNotes = !!opts?.includeNotes;

  return PowerPoint.run(async (context) => {
    const log = (...a: any[]) => console.log("[ppt-dump]", ...a);
    const slides = context.presentation.slides;
    slides.load("items/id,index,name");
    await context.sync();

    const deckOut: string[] = [];
    for (const slide of slides.items) {
      log("slide", { index: slide.index, id: slide.id, name: slide.name });
      const slideParts: string[] = [
        `# Slide ${slide.index + 1}${slide.name ? ` â€” ${slide.name}` : ""}`,
      ];

      // --- slide shapes
      await collectAllTextFromShapes(slide.shapes, slideParts, context, log, "slide");

      // --- notes (optional)
      if (includeNotes) {
        try {
          const notes = (slide as any).notesPage;
          if (notes?.shapes) {
            const notesParts: string[] = [];
            await collectAllTextFromShapes(notes.shapes, notesParts, context, log, "notes");
            if (notesParts.length) {
              slideParts.push("Notes:");
              slideParts.push(notesParts.join("\n"));
            }
          }
        } catch (e) {
          log("notes error", e);
        }
      }

      deckOut.push(slideParts.join("\n"));
    }

    return deckOut.join("\n\n----\n\n");
  });
}

/**
 * Loads *text directly* on shapes and collects:
 *  - Text from TextFrame/textRange
 *  - Tables (values[][] or cell-by-cell fallback)
 *  - Groups (recurses)
 */
async function collectAllTextFromShapes(
  scoped: PowerPoint.ShapeCollection | PowerPoint.ShapeScopedCollection,
  parts: string[],
  ctx: PowerPoint.RequestContext,
  log: (...args: any[]) => void,
  where: "slide" | "notes" | "group"
) {
  // CRITICAL: load textFrame on the shapes themselves (this is what was missing)
  scoped.load(
    "items/id,name,type," +
    "items/textFrame/hasText,items/textFrame/textRange/text," +
    "items/group,items/table"
  );
  await ctx.sync();

  const tables: { id: string; tbl: PowerPoint.Table }[] = [];
  const groups: PowerPoint.ShapeScopedCollection[] = [];

  for (const shape of (scoped as any).items as PowerPoint.Shape[]) {
    log("shape", { where, id: shape.id, name: shape.name, type: shape.type });

    // 1) text from TextFrame (text boxes, placeholders, auto-shapes with text)
    try {
      // With the load above, shape.textFrame is populated if present
      const tf = (shape as any).textFrame as PowerPoint.TextFrame | undefined;
      if (tf && tf.hasText && tf.textRange && typeof tf.textRange.text === "string") {
        const t = (tf.textRange.text || "").trim();
        if (t) {
          parts.push(t);
          log("text", { where, id: shape.id, len: t.length });
        }
      } else if (!tf) {
        // Fallback for older builds: safe getter
        try {
          const safe = shape.getTextFrameOrNullObject();
          safe.load("hasText,textRange/text");
          await ctx.sync();
          if (!(safe as any).isNullObject && safe.hasText && safe.textRange && typeof safe.textRange.text === "string") {
            const t = (safe.textRange.text || "").trim();
            if (t) {
              parts.push(t);
              log("text(fallback)", { where, id: shape.id, len: t.length });
            }
          }
        } catch { /* ignore */ }
      }
    } catch (e) {
      log("textFrame error", { id: shape.id, e });
    }

    // 2) table
    if (shape.type === PowerPoint.ShapeType.table) {
      try { tables.push({ id: String(shape.id), tbl: shape.getTable() }); }
      catch (e) { log("getTable error", { id: shape.id, e }); }
    }

    // 3) group (recurse later)
    if (shape.type === PowerPoint.ShapeType.group) {
      try { groups.push(shape.group.shapes); }
      catch (e) { log("group error", { id: shape.id, e }); }
    }
  }

  // Read tables (values[][] first)
  if (tables.length) {
    for (const t of tables) t.tbl.load("values,rowCount,columnCount");
    await ctx.sync();

    for (const { id, tbl } of tables) {
      let pushed = false;
      try {
        const vals = (tbl as any).values as string[][] | undefined;
        if (Array.isArray(vals)) {
          const text = vals.map(row => row.map(v => (v ?? "").trim()).join("\t")).join("\n").trim();
          if (text) { parts.push(text); pushed = true; log("table(values)", { where, id, rows: tbl.rowCount, cols: tbl.columnCount }); }
        }
      } catch { /* fall back */ }

      if (!pushed && typeof tbl.rowCount === "number" && typeof tbl.columnCount === "number") {
        const rows: string[] = [];
        for (let r = 0; r < tbl.rowCount; r++) {
          const row: string[] = [];
          for (let c = 0; c < tbl.columnCount; c++) {
            const cell = tbl.getCellOrNullObject(r, c);
            cell.load("text");
          }
          await ctx.sync();
          for (let c = 0; c < tbl.columnCount; c++) {
            const cell = tbl.getCellOrNullObject(r, c);
            row.push((cell.text ?? "").trim());
          }
          rows.push(row.join("\t"));
        }
        const t = rows.join("\n").trim();
        if (t) { parts.push(t); log("table(cells)", { where, id, rows: tbl.rowCount, cols: tbl.columnCount }); }
      }
    }
  }

  // Recurse into groups
  for (const inner of groups) {
    await collectAllTextFromShapes(inner, parts, ctx, log, "group");
  }
}
