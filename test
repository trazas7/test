// Import JSZip in your bundle
import JSZip from "jszip";

} else if (Office.context.host === Office.HostType.PowerPoint) {
  await PowerPoint.run(async (context) => {
    const pres = context.presentation;

    // Selection + the selected slideâ€™s ID
    const sel = pres.getSelectedTextRangeOrNullObject();
    const selectedSlides = pres.getSelectedSlides();
    const firstSelected = selectedSlides.getItemAt(0);

    sel.load(["text", "isNullObject"]);
    firstSelected.load("id");           // <-- use id, not index
    await context.sync();

    if (sel.isNullObject) { selectedText = ""; return; }
    const selectedTextRaw = sel.text || "";
    const slideId = firstSelected.id;   // e.g., "256" (p:sldId/@id)

    const zipBlob = await getPptxZipBlob();
    if (!zipBlob) { selectedText = selectedTextRaw; return; }

    const html = await selectionHtmlFromSlideId(zipBlob, slideId, selectedTextRaw);
    selectedText = html || selectedTextRaw;
  });
}

/* ----------------- helpers ----------------- */

// Pull the .pptx contents as a ZIP blob
function getPptxZipBlob(): Promise<Blob | null> {
  return new Promise((resolve) => {
    Office.context.document.getFileAsync(
      Office.FileType.Compressed, { sliceSize: 4_000_000 },
      (res) => {
        if (res.status !== Office.AsyncResultStatus.Succeeded) return resolve(null);
        const file = res.value, chunks: Uint8Array[] = [];
        let i = 0;
        const read = () => file.getSliceAsync(i, (r) => {
          if (r.status !== Office.AsyncResultStatus.Succeeded) { file.closeAsync(); return resolve(null); }
          chunks.push(new Uint8Array(r.value.data));
          if (++i < file.sliceCount) return read();
          file.closeAsync();
          resolve(new Blob(chunks, { type: "application/zip" }));
        });
        read();
      }
    );
  });
}

async function selectionHtmlFromSlideId(zipBlob: Blob, slideId: string, selected: string) {
  const zip = await JSZip.loadAsync(zipBlob);

  // Map slideId -> 'ppt/slides/slideN.xml'
  const presXml   = await zip.file("ppt/presentation.xml")?.async("text");
  const presRels  = await zip.file("ppt/_rels/presentation.xml.rels")?.async("text");
  if (!presXml || !presRels) return "";

  const nsP = "http://schemas.openxmlformats.org/presentationml/2006/main";
  const nsR = "http://schemas.openxmlformats.org/officeDocument/2006/relationships";

  const presDoc = new DOMParser().parseFromString(presXml, "application/xml");
  const relsDoc = new DOMParser().parseFromString(presRels, "application/xml");

  // rId -> Target (e.g., 'slides/slide3.xml')
  const ridToTarget = new Map<string, string>();
  for (const rel of Array.from(relsDoc.getElementsByTagName("Relationship"))) {
    ridToTarget.set(rel.getAttribute("Id")!, rel.getAttribute("Target")!);
  }

  // find the p:sldId with @id == slideId and get its r:id
  const sldIds = Array.from(presDoc.getElementsByTagNameNS(nsP, "sldId"));
  const sld = sldIds.find(n => n.getAttribute("id") === slideId);
  if (!sld) return "";

  const rid = sld.getAttributeNS(nsR, "id");
  const relTarget = rid ? ridToTarget.get(rid) : null;
  if (!relTarget) return "";

  const slidePath = `ppt/${relTarget}`; // e.g., 'ppt/slides/slide3.xml'

  // Build segments (text + href) for this slide, then slice to selection and render HTML
  const segments = await getSegmentsForSlide(zip, slidePath);
  if (!segments.length) return "";

  const sliced = sliceBySelectedText(segments, selected);
  return renderHtml(sliced);
}

async function getSegmentsForSlide(zip: JSZip, slidePath: string) {
  const slideXml = await zip.file(slidePath)?.async("text");
  const relsXml  = await zip.file(slidePath.replace("slides/", "slides/_rels/") + ".rels")?.async("text");
  if (!slideXml || !relsXml) return [];

  const nsA = "http://schemas.openxmlformats.org/drawingml/2006/main";
  const nsR = "http://schemas.openxmlformats.org/officeDocument/2006/relationships";

  const relsDoc = new DOMParser().parseFromString(relsXml, "application/xml");
  const rIdToTarget = new Map<string, string>();
  for (const r of Array.from(relsDoc.getElementsByTagName("Relationship"))) {
    rIdToTarget.set(r.getAttribute("Id")!, r.getAttribute("Target")!);
  }

  const doc = new DOMParser().parseFromString(slideXml, "application/xml");
  const runs = Array.from(doc.getElementsByTagNameNS(nsA, "r"));

  const segments: { text: string; href: string | null }[] = [];
  for (const r of runs) {
    const tNode = r.getElementsByTagNameNS(nsA, "t")[0];
    const text = tNode?.textContent ?? "";
    const rPr = r.getElementsByTagNameNS(nsA, "rPr")[0];
    const h = rPr?.getElementsByTagNameNS(nsA, "hlinkClick")[0];
    const rid = h?.getAttributeNS(nsR, "id") || null;
    const href = rid ? rIdToTarget.get(rid) || null : null;
    segments.push({ text, href });
  }
  return segments;
}

function sliceBySelectedText(
  segments: { text: string; href: string | null }[],
  selected: string
) {
  const full = segments.map(s => s.text).join("");
  let start = full.indexOf(selected);
  if (start < 0) return [];

  const out: { text: string; href: string | null }[] = [];
  let pos = 0, remain = selected.length;

  for (const seg of segments) {
    if (remain <= 0) break;
    const end = pos + seg.text.length;
    if (end > start && pos < start + selected.length) {
      const from = Math.max(0, start - pos);
      const to = Math.min(seg.text.length, start + selected.length - pos);
      const piece = seg.text.slice(from, to);
      if (piece) out.push({ text: piece, href: seg.href });
      remain -= (to - from);
    }
    pos = end;
  }
  return out;
}

function renderHtml(segments: { text: string; href: string | null }[]) {
  const escape = (s: string) =>
    s.replace(/&/g, "&amp;").replace(/</g, "&lt;")
     .replace(/>/g, "&gt;").replace(/"/g, "&quot;");
  const escapeAttr = (s: string) =>
    s.replace(/&/g, "&amp;").replace(/"/g, "&quot;");
  return segments
    .map(s => s.href ? `<a href="${escapeAttr(s.href)}">${escape(s.text)}</a>` : escape(s.text))
    .join("");
}