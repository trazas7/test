export async function getPptSelectedTextOrShape(): Promise<string> {
  console.log("üöÄ Starting getPptSelectedTextOrShape with workaround approaches");
  
  return PowerPoint.run(async (ctx) => {
    try {
      // 1) Try highlighted text first (your existing logic)
      console.log("üîç Step 1: Checking for selected text range");
      const sel = ctx.presentation.getSelectedTextRangeOrNullObject();
      await ctx.sync();
      
      if (!sel.isNullObject) {
        sel.load("text");
        await ctx.sync();
        const textResult = (sel.text ?? "").trim();
        if (textResult) {
          console.log("‚úÖ Returning selected text:", textResult);
          return textResult;
        }
      }

      // 2) Check selected shapes
      const shapes = ctx.presentation.getSelectedShapes();
      shapes.load("items");
      await ctx.sync();
      
      if (shapes.items.length > 0) {
        const shape = shapes.items[0];
        shape.load("type,name");
        await ctx.sync();
        
        console.log(`Shape detected: ${shape.type} - ${shape.name}`);
        
        if (shape.type === "Table") {
          console.log("üèóÔ∏è Table detected, trying workaround methods...");
          
          // Method 1: Try to use PowerPoint's clipboard
          const clipboardText = await tryClipboardMethod();
          if (clipboardText) {
            return clipboardText;
          }
          
          // Method 2: Try OOXML manipulation
          const ooxmlText = await tryOOXMLMethod(ctx);
          if (ooxmlText) {
            return ooxmlText;
          }
          
          // Method 3: Prompt user to copy manually
          return await promptUserToCopy();
        }
        
        // Handle regular text shapes
        if (shape.type === "GeometricShape" || shape.type === "TextBox") {
          try {
            shape.load("textFrame");
            await ctx.sync();
            if (shape.textFrame) {
              shape.textFrame.load("textRange");
              await ctx.sync();
              if (shape.textFrame.textRange) {
                shape.textFrame.textRange.load("text");
                await ctx.sync();
                return shape.textFrame.textRange.text?.trim() || "";
              }
            }
          } catch (e) {
            console.log("Regular text extraction failed:", e);
          }
        }
      }
      
      return "";
    } catch (error) {
      console.error("üí• Fatal error:", error);
      return "";
    }
  });
}

// Method 1: Try using clipboard (requires user permission)
async function tryClipboardMethod(): Promise<string> {
  console.log("üîÑ Trying clipboard method...");
  try {
    // Check if we can access clipboard
    if (navigator.clipboard && navigator.clipboard.readText) {
      // Instruct user to copy the table
      const userConfirmed = confirm(
        "To extract table content, please:\n1. Right-click on the selected table\n2. Choose 'Copy'\n3. Click OK"
      );
      
      if (userConfirmed) {
        const text = await navigator.clipboard.readText();
        console.log("üìã Clipboard content:", text);
        return text.trim();
      }
    }
  } catch (e) {
    console.log("‚ùå Clipboard method failed:", e);
  }
  return "";
}

// Method 2: Try OOXML approach (experimental)
async function tryOOXMLMethod(ctx: PowerPoint.RequestContext): Promise<string> {
  console.log("üîÑ Trying OOXML method...");
  try {
    // Get slide content as OOXML
    const slide = ctx.presentation.slides.getActiveSlide();
    const ooxml = slide.getOoxml();
    await ctx.sync();
    
    console.log("üìÑ OOXML content:", ooxml.value);
    
    // Parse OOXML for table content (basic parsing)
    const tableText = parseTableFromOOXML(ooxml.value);
    return tableText;
  } catch (e) {
    console.log("‚ùå OOXML method failed:", e);
    return "";
  }
}

// Basic OOXML table parser
function parseTableFromOOXML(ooxml: string): string {
  console.log("üîç Parsing OOXML for table content...");
  try {
    // Look for table cells in OOXML
    const parser = new DOMParser();
    const doc = parser.parseFromString(ooxml, 'text/xml');
    
    // Find table cells (a:tc elements)
    const cells = doc.querySelectorAll('a\\:tc, tc');
    let tableText = "";
    let cellCount = 0;
    
    cells.forEach((cell, index) => {
      // Extract text from cell
      const textElements = cell.querySelectorAll('a\\:t, t');
      let cellText = "";
      
      textElements.forEach(textEl => {
        cellText += textEl.textContent || "";
      });
      
      if (cellText.trim()) {
        tableText += cellText.trim();
        cellCount++;
        
        // Add separator (tab for columns, newline for rows - rough estimate)
        if ((cellCount % 3 === 0)) { // Assuming 3 columns, adjust as needed
          tableText += "\n";
        } else {
          tableText += "\t";
        }
      }
    });
    
    console.log("üìä Extracted table text:", tableText);
    return tableText.trim();
    
  } catch (e) {
    console.log("‚ùå OOXML parsing failed:", e);
    return "";
  }
}

// Method 3: Prompt user to manually copy
async function promptUserToCopy(): Promise<string> {
  console.log("üîÑ Prompting user to copy manually...");
  
  return new Promise((resolve) => {
    const modal = document.createElement('div');
    modal.style.cssText = `
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: white; padding: 20px; border: 2px solid #ccc; border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3); z-index: 10000; font-family: Arial;
    `;
    
    modal.innerHTML = `
      <h3>Table Content Extraction</h3>
      <p>Office.js doesn't support table extraction in PowerPoint.</p>
      <p>Please follow these steps:</p>
      <ol>
        <li>Right-click on the selected table</li>
        <li>Choose "Copy" from the context menu</li>
        <li>Paste the content in the text area below:</li>
      </ol>
      <textarea id="tableText" rows="6" cols="50" placeholder="Paste table content here..."></textarea><br><br>
      <button id="confirmBtn">Use This Text</button>
      <button id="cancelBtn" style="margin-left: 10px;">Cancel</button>
    `;
    
    document.body.appendChild(modal);
    
    document.getElementById('confirmBtn')!.onclick = () => {
      const text = (document.getElementById('tableText') as HTMLTextAreaElement).value;
      document.body.removeChild(modal);
      resolve(text.trim());
    };
    
    document.getElementById('cancelBtn')!.onclick = () => {
      document.body.removeChild(modal);
      resolve("");
    };
  });
}