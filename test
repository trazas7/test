// Gets selected text if any; otherwise the text contained in the selected shape(s).
// Handles: text boxes/placeholders, tables (entire table), and groups (recursively).
export async function getPptSelectedTextOrShape(): Promise<string> {
  return PowerPoint.run(async (ctx) => {
    const log = (...a: any[]) => console.log("[getPptSelectedTextOrShape]", ...a);
    const pres = ctx.presentation;

    // 1) Prefer an active text selection (this also works when a table cell's text is selected)
    const sel = pres.getSelectedTextRangeOrNullObject();
    await ctx.sync();
    if (!sel.isNullObject) {
      sel.load("text");
      await ctx.sync();
      const t = (sel.text ?? "").trim();
      log("Active text selection found. Length:", t.length);
      return t;
    }
    log("No active text selection.");

    // 2) Otherwise, get currently selected shapes
    const selected = pres.getSelectedShapes();
    selected.load("items");
    await ctx.sync();

    if (selected.items.length === 0) {
      log("No shapes selected.");
      return "";
    }

    // Load the minimal info we need on each selected shape
    selected.items.forEach((s: any) =>
      s.load("type,textFrame/hasText,textFrame/textRange/text")
    );
    await ctx.sync();
    log(`Selected shapes: ${selected.items.length}`);

    const parts: string[] = [];

    // --- helpers -------------------------------------------------------------

    // Read a table to plain text (tab-delimited rows)
    const readTableFromShape = async (shape: any) => {
      try {
        const table = shape.getTable(); // only valid when shape.type === table
        table.load("rowCount,columnCount");
        await ctx.sync();

        const rows = Number(table.rowCount) || 0;
        const cols = Number(table.columnCount) || 0;
        log("Table detected. Size:", rows, "x", cols);

        // Queue loads for every cell in one go
        const cells: { r: number; c: number; cell: any }[] = [];
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            const cell = table.getCellOrNullObject(r, c);
            cell.load("text,isNullObject");
            cells.push({ r, c, cell });
          }
        }
        await ctx.sync();

        // Build a 2D grid of strings
        const lines: string[] = [];
        for (let r = 0; r < rows; r++) {
          const rowVals: string[] = [];
          for (let c = 0; c < cols; c++) {
            const { cell } = cells[r * cols + c];
            rowVals.push(!cell.isNullObject && typeof cell.text === "string" ? cell.text : "");
          }
          lines.push(rowVals.join("\t"));
        }
        const text = lines.join("\n").trim();
        log("Table text length:", text.length);
        if (text) parts.push(text);
      } catch (err) {
        log("Error while reading table:", err);
      }
    };

    // Recursively collect text from a ShapeScopedCollection (handles nested groups)
    const collectFromShapes = async (scoped: any) => {
      // For nested groups we need to load again
      if (scoped !== selected) {
        scoped.load("items");
        await ctx.sync();
        scoped.items.forEach((s: any) =>
          s.load("type,textFrame/hasText,textFrame/textRange/text")
        );
        await ctx.sync();
      }

      for (const s of scoped.items) {
        log("Visiting shape. type enum value:", s.type);

        // Text-bearing shapes
        if (s.textFrame?.hasText && s.textFrame?.textRange?.text) {
          const t = String(s.textFrame.textRange.text).trim();
          log("TextFrame found. Length:", t.length);
          if (t) parts.push(t);
        }

        // Tables
        if (s.type === PowerPoint.ShapeType.table) {
          log("ShapeType.table matched.");
          await readTableFromShape(s);
        }

        // Groups
        const inner = (s as any).group?.shapes;
        if (inner) {
          log("Descending into group...");
          await collectFromShapes(inner);
        }
      }
    };

    await collectFromShapes(selected);

    const result = parts.join("\n\n");
    log("Final concatenated text length:", result.length);
    return result;
  });
}
