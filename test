// ppt-table-extract-simple.ts
import JSZip from "jszip";

/**
 * One function you call:
 *  - highlighted text ‚Üí returns it
 *  - selected TextBox ‚Üí returns text
 *  - selected Table ‚Üí returns ONLY that table as TSV (or an "ambiguous" message)
 */
export async function getPptSelectedTextOrShape(): Promise<string> {
  const t0 = performance.now();
  log("üöÄ start getPptSelectedTextOrShape");

  // 1) Try highlighted text
  const text = await PowerPoint.run(async (ctx) => {
    try {
      log("üîé step1: highlighted text");
      const sel = ctx.presentation.getSelectedTextRangeOrNullObject();
      await ctx.sync();
      if (!sel.isNullObject) {
        sel.load("text");
        await ctx.sync();
        const t = sel.text?.trim() ?? "";
        log("üñ±Ô∏è selected text =", JSON.stringify(t));
        if (t) return t;
      } else {
        log("‚ÑπÔ∏è no selected text range");
      }

      // 2) Check selected shapes (TextBox or Table)
      log("üîé step2: inspect selected shapes");
      const selShapes = ctx.presentation.getSelectedShapes();
      selShapes.load("items");
      await ctx.sync();
      log("üì¶ selected shapes count:", selShapes.items.length);

      if (selShapes.items.length === 0) return "";

      // Load only safe props for all shapes first
      selShapes.items.forEach((s) =>
        s.load("type,name,left,top,width,height")
      );
      await ctx.sync();

      // Look for TextBox first (quick win)
      for (const s of selShapes.items as any[]) {
        logShapeMeta(s);
        if (s.type === "TextBox") {
          try {
            s.load("textFrame/textRange/text");
            await ctx.sync();
            const txt = s?.textFrame?.textRange?.text?.trim?.() ?? "";
            log("üìù textbox text length:", txt.length);
            if (txt) return txt;
          } catch (e) {
            log("‚ö†Ô∏è textbox read failed:", e);
          }
        }
      }

      // If a Table is selected, return a token to continue outside PowerPoint.run
      for (const s of selShapes.items as any[]) {
        if (s.type === "Table") {
          const shape: SelectedShape = {
            kind: "table",
            pts: {
              left: toNumber(s.left),
              top: toNumber(s.top),
              width: toNumber(s.width),
              height: toNumber(s.height),
            },
          };
          // serialize as JSON so we can pass it out of the run batch
          (window as any).__ppt_lastSelectedTableGeom = shape;
          log("üìä table selected; geom pts:", shape.pts);
          return "__TABLE_SELECTED__";
        }
      }

      log("‚ÑπÔ∏è no textbox/table usable");
      return "";
    } catch (err) {
      log("üí• selection scan error:", err);
      return "";
    }
  });

  if (text && text !== "__TABLE_SELECTED__") {
    logDone(t0, "‚úÖ returning highlighted/textbox text");
    return text;
  }

  // 3) If we flagged a table, continue with ZIP-parsing and geometric match.
  const selected: SelectedShape | undefined = (window as any)
    .__ppt_lastSelectedTableGeom;
  if (!selected || selected.kind !== "table") {
    log("‚õî no selected table; not parsing deck");
    return "Select a single table, then try again.";
  }

  // Build our target in EMU (slide XML uses EMU)
  const targetEMU = ptGeomToEmu(selected.pts);
  log("üìê target geom (EMU):", targetEMU);

  // Pull the deck as ZIP
  const zipArrayBuffer = await getPptxZipArrayBuffer();

  // Extract ALL tables (name + geometry + TSV) from ALL slides
  const { tables, slidesCount } = await extractAllTables(zipArrayBuffer);
  log(`üìÑ slides parsed: ${slidesCount}, total tables found: ${tables.length}`);

  if (tables.length === 0) {
    logDone(t0, "‚ùå no tables in deck");
    return "No tables found in the presentation.";
  }

  // Score geometric similarity and pick the best
  const ranked = rankByGeometry(targetEMU, tables);

  // Show top 5 candidates with their scores for debugging
  log("üèÅ top candidates (lowest score = best):");
  ranked.slice(0, 5).forEach((c, i) =>
    log(
      `   ${i + 1}. score=${fmt(c.score)} slide=${c.slideNo} name=${JSON.stringify(
        c.name
      )} geom=${emuStr(c.geom)}`
    )
  );

  // Decision: if top score is good and clearly better than #2 ‚Üí pick it
  const BEST = ranked[0];
  const SECOND = ranked[1];
  const ACCEPTABLE = BEST.score <= MAX_ACCEPTABLE_SCORE;
  const CLEAR_MARGIN =
    !SECOND || BEST.score + CLEAR_MARGIN_DELTA < SECOND.score;

  if (ACCEPTABLE && CLEAR_MARGIN) {
    log("‚úÖ confident match ‚Üí slide", BEST.slideNo, "name", BEST.name);
    logDone(t0, "‚úÖ returning selected table TSV");
    return BEST.tsv;
  }

  // If ambiguous, don‚Äôt return wrong data ‚Äî tell the user & show debug details
  log(
    "‚ö†Ô∏è ambiguous match; BEST=",
    fmt(BEST.score),
    "SECOND=",
    SECOND ? fmt(SECOND.score) : "n/a"
  );
  const diag = ranked
    .slice(0, 5)
    .map(
      (c, i) =>
        `${i + 1}. score=${fmt(c.score)} slide=${c.slideNo} name=${
          c.name
        } geom=${emuStr(c.geom)}`
    )
    .join("\n");
  return [
    "Ambiguous selection: multiple tables look similar.",
    "Try any of:",
    "  ‚Ä¢ Move the table slightly (position will change).",
    "  ‚Ä¢ Resize the table a bit (size will change).",
    "  ‚Ä¢ Delete/rename duplicate tables.",
    "",
    "Debug (top candidates):",
    diag,
  ].join("\n");
}

/* ======================================================================================
   CONFIG / SCORING
   ==================================================================================== */

/** How strict we are. Lower = stricter. Typical good match is ~0.01‚Äì0.05 */
const MAX_ACCEPTABLE_SCORE = 0.08;
/** How much better BEST must be than SECOND to be ‚Äúclearly‚Äù the match. */
const CLEAR_MARGIN_DELTA = 0.02;

/** geometric score: lower is better; 0 = perfect */
function scoreGeom(a: GeomEMU, b: GeomEMU): number {
  // Normalize deltas by candidate size to be scale-invariant
  const dx = Math.abs(a.x - b.x) / (b.cx || 1);
  const dy = Math.abs(a.y - b.y) / (b.cy || 1);
  const dw = Math.abs(a.cx - b.cx) / (b.cx || 1);
  const dh = Math.abs(a.cy - b.cy) / (b.cy || 1);
  // weight position half of size (tweakable)
  return dx * 0.25 + dy * 0.25 + dw * 0.25 + dh * 0.25;
}

/* ======================================================================================
   TYPES
   ==================================================================================== */
type SelectedShape = {
  kind: "table";
  pts: { left: number; top: number; width: number; height: number };
};

type GeomEMU = { x: number; y: number; cx: number; cy: number };

type ExtractedTable = {
  slideNo: number; // 1-based
  name: string;
  geom: GeomEMU;
  tsv: string;
};

/* ======================================================================================
   ZIP + EXTRACT ALL TABLES
   ==================================================================================== */

async function extractAllTables(
  zip: ArrayBuffer
): Promise<{ tables: ExtractedTable[]; slidesCount: number }> {
  log("üßµ unzip + extract tables");
  const z = await JSZip.loadAsync(zip);

  const slidePaths = Object.keys(z.files)
    .filter((p) => /^ppt\/slides\/slide\d+\.xml$/.test(p))
    .sort((a, b) => {
      const na = parseInt(a.match(/slide(\d+)\.xml/)![1], 10);
      const nb = parseInt(b.match(/slide(\d+)\.xml/)![1], 10);
      return na - nb;
    });

  const all: ExtractedTable[] = [];
  for (const path of slidePaths) {
    const slideNo = parseInt(path.match(/slide(\d+)\.xml/)![1], 10);
    const xml = await z.files[path].async("text");
    const tables = extractTablesOnSlide(xml, slideNo);
    log(`   üß© slide${slideNo}: found ${tables.length} table(s)`);
    all.push(...tables);
  }
  return { tables: all, slidesCount: slidePaths.length };
}

function extractTablesOnSlide(xml: string, slideNo: number): ExtractedTable[] {
  const doc = new DOMParser().parseFromString(xml, "application/xml");
  const frames = Array.from(doc.getElementsByTagNameNS("*", "graphicFrame"));
  const out: ExtractedTable[] = [];

  for (const gf of frames) {
    const graphic = first(gf, "graphic");
    const graphicData = graphic ? first(graphic, "graphicData") : null;
    const tbl = graphicData ? first(graphicData, "tbl") : null;
    if (!tbl) continue;

    // name (optional, may be non-unique)
    const nv = first(gf, "nvGraphicFramePr");
    const cNvPr = nv ? first(nv, "cNvPr") : null;
    const name = (cNvPr?.getAttribute("name") ?? "").trim();

    // geometry (EMU)
    const xfrm = first(gf, "xfrm");
    const off = xfrm ? first(xfrm, "off") : null;
    const ext = xfrm ? first(xfrm, "ext") : null;
    if (!off || !ext) continue;

    const geom: GeomEMU = {
      x: toNumber(off.getAttribute("x")),
      y: toNumber(off.getAttribute("y")),
      cx: toNumber(ext.getAttribute("cx")),
      cy: toNumber(ext.getAttribute("cy")),
    };

    out.push({
      slideNo,
      name,
      geom,
      tsv: tableToTSV(tbl),
    });
  }

  return out;
}

/* ======================================================================================
   MATCHING
   ==================================================================================== */
function rankByGeometry(target: GeomEMU, tables: ExtractedTable[]) {
  return tables
    .map((t) => ({
      ...t,
      score: scoreGeom(target, t.geom),
    }))
    .sort((a, b) => a.score - b.score);
}

/* ======================================================================================
   TABLE ‚Üí TSV
   ==================================================================================== */

function tableToTSV(tblEl: Element): string {
  const rows = Array.from(tblEl.getElementsByTagNameNS("*", "tr"));
  const lines: string[] = [];

  for (let r = 0; r < rows.length; r++) {
    const tr = rows[r];
    const cells = Array.from(tr.getElementsByTagNameNS("*", "tc"));
    const vals = cells.map((tc) => getCellText(tc));
    // trim trailing empty cells
    let end = vals.length;
    while (end > 0 && (!vals[end - 1] || !vals[end - 1].trim())) end--;
    lines.push(vals.slice(0, end).join("\t"));
  }
  while (lines.length && !lines[lines.length - 1].trim()) lines.pop();
  return lines.join("\n");
}

function getCellText(tc: Element): string {
  const doc = tc.ownerDocument!;
  const walker = doc.createTreeWalker(
    tc,
    NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT
  );
  let n: Node | null = walker.nextNode();
  let out = "";
  while (n) {
    if (n.nodeType === Node.ELEMENT_NODE) {
      const el = n as Element;
      if (el.localName === "t") out += el.textContent ?? "";
      else if (el.localName === "br") out += "\n";
    }
    n = walker.nextNode();
  }
  return out.replace(/\s+\n/g, "\n").replace(/\n{3,}/g, "\n\n").trim();
}

/* ======================================================================================
   OFFICE FILE ACCESS
   ==================================================================================== */

async function getPptxZipArrayBuffer(): Promise<ArrayBuffer> {
  log("‚¨áÔ∏è getFileAsync(Compressed) ‚Ä¶");
  const file = await getFileAsync(Office.FileType.Compressed);
  log("‚úÖ file acquired; sliceCount:", file.sliceCount);
  try {
    const parts: Uint8Array[] = [];
    for (let i = 0; i < file.sliceCount; i++) {
      const slice = await getSliceAsync(file, i);
      const u8 = new Uint8Array(slice.value.data as number[]);
      parts.push(u8);
      if (i === 0 || i === file.sliceCount - 1 || (i + 1) % 10 === 0) {
        log(`   üîπ slice ${i + 1}/${file.sliceCount} (${u8.length} B)`);
      }
    }
    const total = parts.reduce((s, p) => s + p.length, 0);
    log("üìè total bytes:", total);

    const merged = new Uint8Array(total);
    let off = 0;
    for (const p of parts) {
      merged.set(p, off);
      off += p.length;
    }
    return merged.buffer;
  } finally {
    file.closeAsync(() => log("üßπ file closed"));
  }
}

function getFileAsync(type: Office.FileType): Promise<Office.File> {
  return new Promise((resolve, reject) => {
    Office.context.document.getFileAsync(type, (res) => {
      if (res.status === Office.AsyncResultStatus.Succeeded) resolve(res.value);
      else {
        log("‚ùå getFileAsync failed:", res.error);
        reject(res.error);
      }
    });
  });
}

function getSliceAsync(file: Office.File, index: number) {
  return new Promise<Office.AsyncResult<Office.Slice>>((resolve, reject) => {
    file.getSliceAsync(index, (res) => {
      if (res.status === Office.AsyncResultStatus.Succeeded) resolve(res);
      else {
        log(`‚ùå getSliceAsync(${index}) failed:`, res.error);
        reject(res.error);
      }
    });
  });
}

/* ======================================================================================
   UTILS
   ==================================================================================== */

function ptGeomToEmu(pts: { left: number; top: number; width: number; height: number }): GeomEMU {
  return {
    x: ptToEmu(pts.left),
    y: ptToEmu(pts.top),
    cx: ptToEmu(pts.width),
    cy: ptToEmu(pts.height),
  };
}

const EMU_PER_PT = 12700;
function ptToEmu(pt: number): number {
  return Math.round(pt * EMU_PER_PT);
}

function first(parent: Element, local: string): Element | null {
  for (let i = 0; i < parent.childNodes.length; i++) {
    const n = parent.childNodes[i];
    if (n.nodeType === Node.ELEMENT_NODE && (n as Element).localName === local) {
      return n as Element;
    }
  }
  return null;
}

function toNumber(v: any): number {
  const n = typeof v === "number" ? v : parseFloat(String(v ?? "0"));
  return Number.isFinite(n) ? n : 0;
}

function fmt(n: number) {
  return (Math.round(n * 10000) / 10000).toFixed(4);
}
function emuStr(g: GeomEMU) {
  return `{x:${g.x},y:${g.y},cx:${g.cx},cy:${g.cy}}`;
}
function log(...a: any[]) {
  // centralized logger for easy filtering
  console.log("[ppt-table-extract]", ...a);
}
function logShapeMeta(s: any) {
  log(
    `‚Ä¢ shape type=${s.type} name=${JSON.stringify(s.name)} box=[${s.left},${s.top},${s.width},${s.height}]`
  );
}
function logDone(t0: number, msg: string) {
  log(msg, `(${Math.round(performance.now() - t0)} ms)`);
}