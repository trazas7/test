// ppt-table-extract-name-aware.ts
import JSZip from "jszip";

/**
 * Call this:
 *  - highlighted text → returns it
 *  - selected TextBox → returns its text
 *  - selected Table → returns ONLY that table as TSV
 * Uses geometry + table name as a tie-breaker.
 */
export async function getPptSelectedTextOrShape(): Promise<string> {
  const t0 = performance.now();
  log("🚀 start");

  // 1) Try selected text / selected shapes (collect table geometry + name)
  const tokenOrText = await PowerPoint.run(async (ctx) => {
    try {
      log("🔎 step1: highlighted text");
      const sel = ctx.presentation.getSelectedTextRangeOrNullObject();
      await ctx.sync();
      if (!sel.isNullObject) {
        sel.load("text");
        await ctx.sync();
        const t = sel.text?.trim() ?? "";
        log("🖱️ selected text =", JSON.stringify(t));
        if (t) return t;
      } else {
        log("ℹ️ no selected text range");
      }

      log("🔎 step2: inspect selected shapes");
      const ss = ctx.presentation.getSelectedShapes();
      ss.load("items");
      await ctx.sync();
      log("📦 selected shapes:", ss.items.length);
      if (ss.items.length === 0) return "";

      // Load safe props first; read TextBox text lazily
      ss.items.forEach((s) => s.load("type,name,left,top,width,height"));
      await ctx.sync();

      // If there's a TextBox, return its text
      for (const s of ss.items as any[]) {
        logShapeMeta(s);
        if (s.type === "TextBox") {
          try {
            s.load("textFrame/textRange/text");
            await ctx.sync();
            const txt = s?.textFrame?.textRange?.text?.trim?.() ?? "";
            log("📝 textbox text length:", txt.length);
            if (txt) return txt;
          } catch (e) {
            log("⚠️ textbox read failed:", e);
          }
        }
      }

      // If we have a Table, store its geometry + name in window and emit a token
      for (const s of ss.items as any[]) {
        if (s.type === "Table") {
          const payload: SelectedTable = {
            leftPt: num(s.left),
            topPt: num(s.top),
            widthPt: num(s.width),
            heightPt: num(s.height),
            name: (s.name ?? "").toString(),
          };
          (window as any).__ppt_selected_table = payload;
          log("📊 table selected:", payload);
          return "__TABLE_SELECTED__";
        }
      }

      log("ℹ️ no textbox/table usable");
      return "";
    } catch (err) {
      log("💥 selection scan error:", err);
      return "";
    }
  });

  if (tokenOrText && tokenOrText !== "__TABLE_SELECTED__") {
    logDone(t0, "✅ returning highlighted/textbox text");
    return tokenOrText;
  }

  const selected: SelectedTable | undefined = (window as any).__ppt_selected_table;
  if (!selected) {
    log("⛔ no selected table; not parsing deck");
    return "Select a single table, then try again.";
  }

  // 2) Parse the deck and find the best match (geometry + name)
  const targetEMU = ptGeomToEmu(selected);
  log("📐 target geom (EMU):", targetEMU, "name:", JSON.stringify(selected.name));

  const zipBuf = await getPptxZipArrayBuffer();
  const { tables, slidesCount } = await extractAllTables(zipBuf);
  log(`📄 slides parsed: ${slidesCount}, total tables: ${tables.length}`);

  if (tables.length === 0) {
    logDone(t0, "❌ no tables found");
    return "No tables found in the presentation.";
  }

  const ranked = rankCandidates(targetEMU, selected.name, tables);

  log("🏁 top candidates (lower = better):");
  ranked.slice(0, 5).forEach((c, i) =>
    log(
      `  ${i + 1}. final=${fmt(c.final)} geom=${fmt(c.geomScore)} penalty=${fmt(
        c.namePenalty
      )} slide=${c.slideNo} name=${JSON.stringify(c.name)} geom=${emuStr(c.geom)}`
    )
  );

  const BEST = ranked[0];
  const SECOND = ranked[1];

  // decide
  const ACCEPTABLE = BEST.final <= MAX_ACCEPTABLE_FINAL;
  const CLEAR_MARGIN = !SECOND || BEST.final + CLEAR_MARGIN_DELTA < SECOND.final;

  if (ACCEPTABLE && CLEAR_MARGIN) {
    log(
      "✅ confident match: slide",
      BEST.slideNo,
      "name",
      BEST.name,
      "final",
      fmt(BEST.final)
    );
    logDone(t0, "✅ returning selected table TSV");
    return BEST.tsv;
  }

  // If still ambiguous, surface helpful debug
  const diag = ranked
    .slice(0, 5)
    .map(
      (c, i) =>
        `${i + 1}. final=${fmt(c.final)} (geom=${fmt(c.geomScore)}, penalty=${fmt(
          c.namePenalty
        )}) slide=${c.slideNo} name=${c.name} geom=${emuStr(c.geom)}`
    )
    .join("\n");

  return [
    "Ambiguous selection: multiple tables look similar.",
    "Tips:",
    "  • Move or resize the table a bit, then try again.",
    "  • Rename the table to a unique name (we use names as a tie-breaker).",
    "",
    "Debug (top candidates):",
    diag,
  ].join("\n");
}

/* =============================== config & scoring =============================== */

// Pure-geometry score (0 = perfect) from 0–~0.3 typical.
// We add a penalty if names don't match to push the right one to the top.
const NAME_MISMATCH_PENALTY = 0.05;   // tweak: bigger = stronger preference for same name
const MAX_ACCEPTABLE_FINAL = 0.10;    // accept only if final score <= this
const CLEAR_MARGIN_DELTA   = 0.02;    // best must beat #2 by this delta

function scoreGeom(a: GeomEMU, b: GeomEMU): number {
  // Normalize deltas by candidate size for scale invariance
  const dx = Math.abs(a.x - b.x) / (b.cx || 1);
  const dy = Math.abs(a.y - b.y) / (b.cy || 1);
  const dw = Math.abs(a.cx - b.cx) / (b.cx || 1);
  const dh = Math.abs(a.cy - b.cy) / (b.cy || 1);
  // equal weights
  return (dx + dy + dw + dh) / 4;
}

function rankCandidates(
  target: GeomEMU,
  selectedName: string,
  tables: ExtractedTable[]
) {
  const selNorm = normalizeName(selectedName);
  return tables
    .map((t) => {
      const geomScore = scoreGeom(target, t.geom);
      const namePenalty =
        selNorm && normalizeName(t.name) === selNorm ? 0 : NAME_MISMATCH_PENALTY;
      const final = geomScore + namePenalty;
      return { ...t, geomScore, namePenalty, final };
    })
    .sort((a, b) => a.final - b.final);
}

/* ================================ types ================================= */

type SelectedTable = {
  leftPt: number;
  topPt: number;
  widthPt: number;
  heightPt: number;
  name: string; // may be non-unique; used only as tie-breaker
};

type GeomEMU = { x: number; y: number; cx: number; cy: number };

type ExtractedTable = {
  slideNo: number; // 1-based
  name: string;
  geom: GeomEMU;
  tsv: string;
};

/* ============================== extract tables ============================== */

async function extractAllTables(
  zip: ArrayBuffer
): Promise<{ tables: ExtractedTable[]; slidesCount: number }> {
  log("🧵 unzip + extract tables");
  const z = await JSZip.loadAsync(zip);

  const slidePaths = Object.keys(z.files)
    .filter((p) => /^ppt\/slides\/slide\d+\.xml$/.test(p))
    .sort((a, b) => {
      const na = parseInt(a.match(/slide(\d+)\.xml/)![1], 10);
      const nb = parseInt(b.match(/slide(\d+)\.xml/)![1], 10);
      return na - nb;
    });

  const all: ExtractedTable[] = [];
  for (const path of slidePaths) {
    const slideNo = parseInt(path.match(/slide(\d+)\.xml/)![1], 10);
    const xml = await z.files[path].async("text");
    const tables = extractTablesOnSlide(xml, slideNo);
    log(`   🧩 slide${slideNo}: ${tables.length} table(s)`);
    all.push(...tables);
  }
  return { tables: all, slidesCount: slidePaths.length };
}

function extractTablesOnSlide(xml: string, slideNo: number): ExtractedTable[] {
  const doc = new DOMParser().parseFromString(xml, "application/xml");
  const frames = Array.from(doc.getElementsByTagNameNS("*", "graphicFrame"));
  const out: ExtractedTable[] = [];

  for (const gf of frames) {
    const g = first(gf, "graphic");
    const gd = g ? first(g, "graphicData") : null;
    const tbl = gd ? first(gd, "tbl") : null;
    if (!tbl) continue;

    const nv = first(gf, "nvGraphicFramePr");
    const cNvPr = nv ? first(nv, "cNvPr") : null;
    const name = (cNvPr?.getAttribute("name") ?? "").trim();

    const xfrm = first(gf, "xfrm");
    const off = xfrm ? first(xfrm, "off") : null;
    const ext = xfrm ? first(xfrm, "ext") : null;
    if (!off || !ext) continue;

    const geom: GeomEMU = {
      x: num(off.getAttribute("x")),
      y: num(off.getAttribute("y")),
      cx: num(ext.getAttribute("cx")),
      cy: num(ext.getAttribute("cy")),
    };

    out.push({ slideNo, name, geom, tsv: tableToTSV(tbl) });
  }
  return out;
}

/* =============================== TSV helpers =============================== */

function tableToTSV(tblEl: Element): string {
  const rows = Array.from(tblEl.getElementsByTagNameNS("*", "tr"));
  const lines: string[] = [];
  for (const tr of rows) {
    const cells = Array.from(tr.getElementsByTagNameNS("*", "tc"));
    const vals = cells.map((tc) => getCellText(tc));
    // trim trailing empty cells
    let end = vals.length;
    while (end > 0 && (!vals[end - 1] || !vals[end - 1].trim())) end--;
    lines.push(vals.slice(0, end).join("\t"));
  }
  while (lines.length && !lines[lines.length - 1].trim()) lines.pop();
  return lines.join("\n");
}

function getCellText(tc: Element): string {
  const doc = tc.ownerDocument!;
  const walker = doc.createTreeWalker(
    tc,
    NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT
  );
  let n: Node | null = walker.nextNode();
  let out = "";
  while (n) {
    if (n.nodeType === Node.ELEMENT_NODE) {
      const el = n as Element;
      if (el.localName === "t") out += el.textContent ?? "";
      else if (el.localName === "br") out += "\n";
    }
    n = walker.nextNode();
  }
  return out.replace(/\s+\n/g, "\n").replace(/\n{3,}/g, "\n\n").trim();
}

/* ============================ Office file access ============================ */

async function getPptxZipArrayBuffer(): Promise<ArrayBuffer> {
  log("⬇️ getFileAsync(Compressed) …");
  const file = await getFileAsync(Office.FileType.Compressed);
  log("✅ file acquired; sliceCount:", file.sliceCount);
  try {
    const parts: Uint8Array[] = [];
    for (let i = 0; i < file.sliceCount; i++) {
      const slice = await getSliceAsync(file, i);
      const u8 = new Uint8Array(slice.value.data as number[]);
      parts.push(u8);
      if (i === 0 || i === file.sliceCount - 1 || (i + 1) % 10 === 0) {
        log(`   🔹 slice ${i + 1}/${file.sliceCount} (${u8.length} B)`);
      }
    }
    const total = parts.reduce((s, p) => s + p.length, 0);
    log("📏 total bytes:", total);

    const merged = new Uint8Array(total);
    let off = 0;
    for (const p of parts) {
      merged.set(p, off);
      off += p.length;
    }
    return merged.buffer;
  } finally {
    file.closeAsync(() => log("🧹 file closed"));
  }
}

function getFileAsync(type: Office.FileType): Promise<Office.File> {
  return new Promise((resolve, reject) => {
    Office.context.document.getFileAsync(type, (res) => {
      if (res.status === Office.AsyncResultStatus.Succeeded) resolve(res.value);
      else {
        log("❌ getFileAsync failed:", res.error);
        reject(res.error);
      }
    });
  });
}

function getSliceAsync(file: Office.File, index: number) {
  return new Promise<Office.AsyncResult<Office.Slice>>((resolve, reject) => {
    file.getSliceAsync(index, (res) => {
      if (res.status === Office.AsyncResultStatus.Succeeded) resolve(res);
      else {
        log(`❌ getSliceAsync(${index}) failed:`, res.error);
        reject(res.error);
      }
    });
  });
}

/* ================================= utils ================================= */

type GeomPts = { leftPt: number; topPt: number; widthPt: number; heightPt: number };

const EMU_PER_PT = 12700;
function ptGeomToEmu(g: GeomPts): GeomEMU {
  return {
    x: Math.round(g.leftPt * EMU_PER_PT),
    y: Math.round(g.topPt * EMU_PER_PT),
    cx: Math.round(g.widthPt * EMU_PER_PT),
    cy: Math.round(g.heightPt * EMU_PER_PT),
  };
}

function first(parent: Element, local: string): Element | null {
  for (let i = 0; i < parent.childNodes.length; i++) {
    const n = parent.childNodes[i];
    if (n.nodeType === Node.ELEMENT_NODE && (n as Element).localName === local) {
      return n as Element;
    }
  }
  return null;
}

function normalizeName(n: string) {
  return (n ?? "").trim().replace(/\s+/g, " ").toLowerCase();
}

function num(v: any): number {
  const n = typeof v === "number" ? v : parseFloat(String(v ?? "0"));
  return Number.isFinite(n) ? n : 0;
}

function fmt(n: number) {
  return (Math.round(n * 10000) / 10000).toFixed(4);
}
function emuStr(g: GeomEMU) {
  return `{x:${g.x},y:${g.y},cx:${g.cx},cy:${g.cy}}`;
}
function log(...a: any[]) {
  console.log("[ppt-table-extract]", ...a);
}
function logShapeMeta(s: any) {
  log(
    `• shape type=${s.type} name=${JSON.stringify(
      s.name
    )} box=[${s.left},${s.top},${s.width},${s.height}]`
  );
}
function logDone(t0: number, msg: string) {
  log(msg, `(${Math.round(performance.now() - t0)} ms)`);
}