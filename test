export async function getPptSelectedTextOrShape(): Promise<string> {
  console.log("=== Starting getPptSelectedTextOrShape ===");

  // PRIORITY 1: Try Common API for selected text (works better with table cells)
  console.log("Step 1: Trying Common API getSelectedDataAsync...");
  
  const commonApiResult = await new Promise<string>((resolve) => {
    Office.context.document.getSelectedDataAsync(
      Office.CoercionType.Text,
      (result) => {
        console.log("Common API status:", result.status);
        console.log("Common API value:", result.value);
        
        if (result.status === Office.AsyncResultStatus.Succeeded && result.value) {
          const text = result.value.trim();
          if (text) {
            console.log("✅ Common API returned text:", text);
            resolve(text);
            return;
          }
        }
        console.log("⚠️ Common API didn't return text");
        resolve("");
      }
    );
  });

  if (commonApiResult) {
    console.log("✅ Returning text from Common API");
    return commonApiResult;
  }

  // PRIORITY 2: Try PowerPoint-specific API for text range
  console.log("\nStep 2: Trying PowerPoint API getSelectedTextRange...");
  
  return PowerPoint.run(async (context) => {
    const pres = context.presentation;
    
    try {
      const selectedText = pres.getSelectedTextRange();
      selectedText.load("text,start,length");
      await context.sync();
      
      console.log("PowerPoint API text:", selectedText.text);
      
      if (selectedText.text && selectedText.text.trim() !== "") {
        console.log("✅ Returning text from PowerPoint API");
        return selectedText.text.trim();
      }
    } catch (error) {
      console.log("⚠️ PowerPoint API error:", error.message);
    }

    // PRIORITY 3: Check for selected shapes
    console.log("\nStep 3: Checking for selected shapes...");
    const selectedShapes = pres.getSelectedShapes();
    selectedShapes.load("items/type,id,name");
    await context.sync();
    
    console.log("Number of selected shapes:", selectedShapes.items.length);
    
    if (selectedShapes.items.length === 0) {
      console.log("⚠️ No shapes selected");
      return "";
    }

    selectedShapes.items.forEach((shape, index) => {
      console.log(`Shape ${index}:`, {
        type: shape.type,
        id: shape.id,
        name: shape.name
      });
    });

    const parts: string[] = [];

    async function collectFromShapes(scoped: PowerPoint.ShapeScopedCollection) {
      console.log("\n--- Entering collectFromShapes ---");
      scoped.load("items/type,id,name");
      await context.sync();

      const frames: PowerPoint.TextFrame[] = [];
      const tables: PowerPoint.Table[] = [];
      const toRecurse: PowerPoint.ShapeScopedCollection[] = [];

      for (const shape of scoped.items) {
        console.log(`Processing shape: ${shape.name}, type: ${shape.type}`);
        
        if (shape.type === PowerPoint.ShapeType.group) {
          console.log("  → Shape is a group");
          const inner = shape.group.shapes;
          toRecurse.push(inner);
        } else if (shape.type === PowerPoint.ShapeType.table) {
          console.log("  → Shape is a table");
          const table = shape.getTable();
          table.load("values,rowCount,columnCount");
          tables.push(table);
        } else {
          console.log("  → Checking for text frame");
          const tf = shape.getTextFrameOrNullObject();
          tf.load("hasText,textRange/text");
          frames.push(tf);
        }
      }

      await context.sync();

      // Get text frames
      for (const tf of frames) {
        if (!tf.isNullObject && tf.hasText && typeof tf.textRange.text === "string") {
          const t = (tf.textRange.text || "").trim();
          if (t) parts.push(t);
        }
      }

      // Get tables
      for (const tbl of tables) {
        if (Array.isArray(tbl.values)) {
          const t = tbl.values.map(row => row.join("\t")).join("\n").trim();
          if (t) parts.push(t);
        }
      }

      // Recurse into groups
      for (const inner of toRecurse) {
        await collectFromShapes(inner);
      }
    }

    await collectFromShapes(selectedShapes);

    console.log("\n=== Final Result ===");
    console.log("Total parts collected:", parts.length);
    console.log("Result:", parts.join("\n\n"));
    console.log("=== End ===\n");

    return parts.join("\n\n");
  });
}
