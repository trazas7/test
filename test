console.log("üîé step 2: inspect selected shapes");
const shapes = ctx.presentation.getSelectedShapes();
shapes.load("items");
await ctx.sync();
console.log("üì¶ selected shapes:", shapes.items.length);

if (shapes.items.length > 0) {
  // First load type + name (safe for all shapes)
  shapes.items.forEach((s) => s.load("type,name"));
  await ctx.sync();

  for (const s of shapes.items as any[]) {
    console.log(`‚Ä¢ shape name=${s.name} type=${s.type}`);

    if (s.type === "TextBox") {
      try {
        // only for TextBoxes: load textFrame
        s.load("textFrame/textRange/text");
        await ctx.sync();
        const txt = s?.textFrame?.textRange?.text?.trim?.();
        if (txt) {
          console.log("üìù returning textbox text");
          return txt;
        }
      } catch (e) {
        console.log("‚ö†Ô∏è failed to read textbox text:", e);
      }
    }

    if (s.type === "Table" && !selectedTableName) {
      selectedTableName = s.name ?? null;
      console.log("üìä table selected; name:", selectedTableName);
    }
  }
} else {
  console.log("‚ÑπÔ∏è no shapes selected");
}