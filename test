/**
 * Selection → selected shapes → whole deck (slides [+layout/master/notes]).
 * Captures: text frames (text boxes, placeholders, auto-shapes), tables (values → cells), groups (if supported).
 * Very verbose logs for debugging.
 */
export async function getSelectedOrAllPptText(opts?: {
  includeLayout?: boolean;     // default: true
  includeMaster?: boolean;     // default: true
  includeNotes?: boolean;      // default: false
  maxChars?: number;           // optional cap for LLM
}): Promise<string> {
  const includeLayout = opts?.includeLayout ?? true;
  const includeMaster = opts?.includeMaster ?? true;
  const includeNotes  = opts?.includeNotes  ?? false;
  const maxChars      = opts?.maxChars;

  return PowerPoint.run(async (context) => {
    const log = (...a: any[]) => console.log("[ppt-extract]", ...a);
    const t0 = Date.now();

    /* 0) Env info (useful when comparing tenants/builds) */
    try {
      log("PowerPointApi supported:", {
        ">=1.5": Office.context.requirements.isSetSupported("PowerPointApi","1.5"),
        ">=1.6": Office.context.requirements.isSetSupported("PowerPointApi","1.6"),
      });
    } catch {}

    /* 1) Explicit text selection */
    try {
      const sel = context.presentation.getSelectedTextRangeOrNullObject();
      await context.sync();
      if (!sel.isNullObject) {
        sel.load("text");
        await context.sync();
        const t = (sel.text ?? "").trim();
        if (t) {
          log("RETURN selection text", { length: t.length });
          return capIfNeeded(t, maxChars, log, "selection");
        }
      }
    } catch (e) {
      log("selection-text error", e);
    }

    /* 2) Selected shapes (if any) */
    try {
      const ss = context.presentation.getSelectedShapes();
      ss.load("items/id,name,type");
      await context.sync();
      log("selected-shapes", { count: ss.items?.length });
      if (ss.items?.length) {
        const parts: string[] = [];
        await collectTextFromShapes(ss, parts, context, log, "selected");
        const out = parts.join("\n\n").trim();
        log("selected-shapes result", { chunks: parts.length, length: out.length });
        if (out) return capIfNeeded(out, maxChars, log, "selected-shapes");
      }
    } catch (e) {
      log("selected-shapes error", e);
    }

    /* 3) Whole deck walk */
    const slides = context.presentation.slides;
    slides.load("items/id,index,name");
    await context.sync();
    log("deck", { slideCount: slides.items.length });

    const deck: string[] = [];

    for (const slide of slides.items) {
      const header = `# Slide ${slide.index + 1}${slide.name ? ` — ${slide.name}` : ""}`;
      const parts: string[] = [header];

      await collectTextFromShapes(slide.shapes, parts, context, log, `slide:${slide.index + 1}`);

      if (includeLayout) {
        try {
          const layout = (slide as any).layout;
          if (layout?.shapes) {
            await collectTextFromShapes(layout.shapes, parts, context, log, `layout:${slide.index + 1}`);
          }
        } catch (e) { log("layout error", { slide: slide.index + 1, e }); }
      }

      if (includeMaster) {
        try {
          const master = (slide as any).master;
          if (master?.shapes) {
            await collectTextFromShapes(master.shapes, parts, context, log, `master:${slide.index + 1}`);
          }
        } catch (e) { log("master error", { slide: slide.index + 1, e }); }
      }

      if (includeNotes) {
        try {
          const notes = (slide as any).notesPage;
          if (notes?.shapes) {
            const noteParts: string[] = [];
            await collectTextFromShapes(notes.shapes, noteParts, context, log, `notes:${slide.index + 1}`);
            if (noteParts.length) {
              parts.push("Notes:");
              parts.push(noteParts.join("\n"));
            }
          }
        } catch (e) { log("notes error", { slide: slide.index + 1, e }); }
      }

      deck.push(parts.join("\n"));
    }

    const result = deck.join("\n\n----\n\n").trim();
    log("RETURN deck", { length: result.length, ms: Date.now() - t0 });
    return capIfNeeded(result, maxChars, log, "deck");
  });
}

/* ----------------------------- helpers below ------------------------------ */

/**
 * Reads text from a ShapeCollection or ShapeScopedCollection.
 * Strategy:
 *  - First load minimal metadata (id/name/type) for logging.
 *  - Then **batch-load textFrame on every shape** (hasText + textRange.text) and read it.
 *  - Handle tables (values → cell fallback).
 *  - Recurse into groups **only if** group.shapes exists on this build.
 *  - Never call getTextFrameOrNullObject unless it exists.
 */
async function collectTextFromShapes(
  scoped: PowerPoint.ShapeCollection | PowerPoint.ShapeScopedCollection,
  out: string[],
  ctx: PowerPoint.RequestContext,
  log: (...a: any[]) => void,
  where: string
) {
  // Load metadata for logging
  scoped.load("items/id,name,type");
  await ctx.sync();

  const items = (scoped as any).items as PowerPoint.Shape[] || [];
  log("shapes", { where, count: items.length });

  // 1) Batch-load textFrame on *every* shape (this avoids missing-method issues)
  for (const sh of items) {
    try {
      sh.load("textFrame/hasText,textFrame/textRange/text");
    } catch (e) {
      // Some proxies may throw on load; ignore and continue
      log("shape load(textFrame) error", { where, id: sh.id, e });
    }
  }
  await ctx.sync();

  let pushedText = 0;

  for (const sh of items) {
    log("shape", { where, id: sh.id, name: (sh as any).name, type: (sh as any).type });

    // Text frames (direct)
    try {
      const tf = (sh as any).textFrame as PowerPoint.TextFrame | undefined;
      if (tf && tf.textRange && typeof tf.textRange.text === "string") {
        const s = (tf.textRange.text || "").trim();
        if (s) { out.push(s); pushedText++; }
      }
    } catch (e) {
      log("textFrame read error", { where, id: sh.id, e });
    }
  }
  log("text-summary", { where, pushedText });

  // 2) Tables (values → cells)
  const tables: { id: string; tbl: PowerPoint.Table }[] = [];
  for (const sh of items) {
    if ((sh as any).type === PowerPoint.ShapeType.table) {
      try { tables.push({ id: String(sh.id), tbl: sh.getTable() }); }
      catch (e) { log("getTable error", { where, id: sh.id, e }); }
    }
  }

  if (tables.length) {
    try {
      for (const t of tables) t.tbl.load("values,rowCount,columnCount");
      await ctx.sync();

      for (const { id, tbl } of tables) {
        let pushed = false;
        try {
          const vals = (tbl as any).values as string[][] | undefined;
          if (Array.isArray(vals)) {
            const text = vals.map(r => r.map(v => (v ?? "").trim()).join("\t")).join("\n").trim();
            if (text) { out.push(text); pushed = true; log("table(values)", { where, id, rows: tbl.rowCount, cols: tbl.columnCount }); }
          }
        } catch { /* fall through */ }

        if (!pushed && typeof tbl.rowCount === "number" && typeof tbl.columnCount === "number") {
          const lines: string[] = [];
          for (let r = 0; r < tbl.rowCount; r++) {
            for (let c = 0; c < tbl.columnCount; c++) tbl.getCellOrNullObject(r, c).load("text");
            await ctx.sync(); // load current row
            const row: string[] = [];
            for (let c = 0; c < tbl.columnCount; c++) row.push((tbl.getCellOrNullObject(r, c).text ?? "").trim());
            lines.push(row.join("\t"));
          }
          const t = lines.join("\n").trim();
          if (t) { out.push(t); log("table(cells)", { where, rows: tbl.rowCount, cols: tbl.columnCount }); }
        }
      }
    } catch (e) {
      log("tables read error", { where, e });
    }
  }

  // 3) Groups (recurse only if supported)
  const groups: PowerPoint.ShapeScopedCollection[] = [];
  for (const sh of items) {
    if ((sh as any).type === PowerPoint.ShapeType.group) {
      try {
        const inner = (sh as any).group?.shapes;
        if (inner) groups.push(inner);
        else log("GROUP_UNREADABLE", { where, id: sh.id, note: "group.shapes not available on this build" });
      } catch (e) {
        log("GROUP_UNREADABLE", { where, id: sh.id, e });
      }
    }
  }
  for (const g of groups) {
    await collectTextFromShapes(g, out, ctx, log, `${where}::group`);
  }
}

function capIfNeeded(text: string, max: number | undefined, log: (...a: any[]) => void, where: string) {
  if (!max || text.length <= max) return text;
  log("TRUNCATED", { where, from: text.length, to: max });
  return text.slice(0, max) + "\n\n[TRUNCATED]";
}
