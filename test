/**
 * Returns the selected text if any; otherwise the textual content of the
 * selected shapes (including grouped shapes and tables).
 *
 * Priority:
 *  1) Common Office API selected text (works well with table cells)
 *  2) PowerPoint selected text range
 *  3) Text from selected shapes (text frames, tables, and groups)
 *
 * Always resolves to a string (possibly empty).
 */
export async function getPptSelectedTextOrShape(): Promise<string> {
  // 1) Common API â€” fast & cross-host
  const commonText = await new Promise<string>((resolve) => {
    try {
      Office.context.document.getSelectedDataAsync(
        Office.CoercionType.Text,
        (result) => {
          if (
            result &&
            result.status === Office.AsyncResultStatus.Succeeded &&
            typeof result.value === "string"
          ) {
            resolve(result.value.trim() || "");
          } else {
            resolve("");
          }
        }
      );
    } catch {
      resolve("");
    }
  });

  if (commonText) return commonText;

  // 2) PowerPoint-specific fallback
  return PowerPoint.run(async (context) => {
    const pres = context.presentation;

    // 2a) Use an explicitly selected text range if available
    try {
      const range = pres.getSelectedTextRange();
      range.load("text");
      await context.sync();

      if (range && typeof range.text === "string" && range.text.trim()) {
        return range.text.trim();
      }
    } catch {
      // Ignore and continue to shapes fallback
    }

    // 3) Gather text from selected shapes
    const selected = pres.getSelectedShapes();
    selected.load("items/type");
    await context.sync();

    if (!selected.items || selected.items.length === 0) return "";

    const parts: string[] = [];

    async function collectFromShapes(
      scope: PowerPoint.ShapeScopedCollection
    ): Promise<void> {
      scope.load("items/type");
      await context.sync();

      const frames: PowerPoint.TextFrame[] = [];
      const tables: PowerPoint.Table[] = [];
      const groups: PowerPoint.ShapeScopedCollection[] = [];

      for (const shape of scope.items) {
        if (shape.type === PowerPoint.ShapeType.group) {
          groups.push(shape.group.shapes);
        } else if (shape.type === PowerPoint.ShapeType.table) {
          const tbl = shape.getTable();
          // We only need values for simple extraction
          tbl.load("values");
          tables.push(tbl);
        } else {
          const tf = shape.getTextFrameOrNullObject();
          tf.load("hasText,textRange/text");
          frames.push(tf);
        }
      }

      await context.sync();

      // Text frames
      for (const tf of frames) {
        if (
          !tf.isNullObject &&
          tf.hasText &&
          tf.textRange &&
          typeof tf.textRange.text === "string"
        ) {
          const t = tf.textRange.text.trim();
          if (t) parts.push(t);
        }
      }

      // Tables (values is a 2D array of strings when available)
      for (const tbl of tables) {
        const values = (tbl as unknown as { values?: string[][] }).values;
        if (Array.isArray(values)) {
          const t = values.map((row) => row.join("\t")).join("\n").trim();
          if (t) parts.push(t);
        }
      }

      // Recurse into groups
      for (const inner of groups) {
        await collectFromShapes(inner);
      }
    }

    await collectFromShapes(selected);
    return parts.join("\n\n");
  });
}
