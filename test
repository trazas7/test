export async function getPptSelectedTextOrShape(): Promise<string> {
  console.log("üöÄ Starting automated table extraction");
  
  return PowerPoint.run(async (ctx) => {
    try {
      // 1) Try highlighted text first
      const sel = ctx.presentation.getSelectedTextRangeOrNullObject();
      await ctx.sync();
      
      if (!sel.isNullObject) {
        sel.load("text");
        await ctx.sync();
        const textResult = (sel.text ?? "").trim();
        if (textResult) {
          return textResult;
        }
      }

      // 2) Check selected shapes
      const shapes = ctx.presentation.getSelectedShapes();
      shapes.load("items");
      await ctx.sync();
      
      if (shapes.items.length > 0) {
        const shape = shapes.items[0];
        shape.load("type,name");
        await ctx.sync();
        
        if (shape.type === "Table") {
          console.log("üèóÔ∏è Table detected, trying automated extraction methods...");
          
          // Method 1: Advanced OOXML parsing
          const ooxmlText = await extractTableViaAdvancedOOXML(ctx, shape);
          if (ooxmlText) return ooxmlText;
          
          // Method 2: PowerPoint COM automation (if available)
          const comText = await extractTableViaCOM(ctx, shape);
          if (comText) return comText;
          
          // Method 3: Try undocumented Office.js properties
          const undocumentedText = await extractTableViaUndocumentedAPI(ctx, shape);
          if (undocumentedText) return undocumentedText;
          
          // Method 4: Binary extraction approach
          const binaryText = await extractTableViaBinaryMethod(ctx);
          if (binaryText) return binaryText;
          
          console.log("‚ùå All automated methods failed");
          return "Table detected but extraction not supported by current PowerPoint API";
        }
        
        // Handle regular text shapes
        return await extractRegularTextShape(ctx, shape);
      }
      
      return "";
    } catch (error) {
      console.error("üí• Fatal error:", error);
      return "";
    }
  });
}

// Method 1: Advanced OOXML with comprehensive XML parsing
async function extractTableViaAdvancedOOXML(ctx: PowerPoint.RequestContext, shape: PowerPoint.Shape): Promise<string> {
  console.log("üîÑ Method 1: Advanced OOXML extraction");
  
  try {
    // Try multiple OOXML sources
    const sources = [
      async () => {
        const ooxml = shape.getOoxml();
        await ctx.sync();
        return ooxml.value;
      },
      async () => {
        const slide = ctx.presentation.slides.getActiveSlide();
        const ooxml = slide.getOoxml();
        await ctx.sync();
        return ooxml.value;
      },
      async () => {
        const ooxml = ctx.presentation.getOoxml();
        await ctx.sync();
        return ooxml.value;
      }
    ];
    
    for (const source of sources) {
      try {
        const xml = await source();
        const tableText = parseAdvancedTableXML(xml);
        if (tableText) {
          console.log("‚úÖ OOXML extraction successful");
          return tableText;
        }
      } catch (e) {
        console.log("OOXML source failed, trying next...");
      }
    }
  } catch (error) {
    console.log("‚ùå Advanced OOXML failed:", error);
  }
  
  return "";
}

// Enhanced XML parser with multiple PowerPoint table formats
function parseAdvancedTableXML(xml: string): string {
  console.log("üîç Advanced XML parsing started");
  
  try {
    const parser = new DOMParser();
    const doc = parser.parseFromString(xml, 'text/xml');
    
    // Multiple table detection strategies
    const tableSelectors = [
      'a\\:tbl, tbl',
      '[*|localName="tbl"]',
      'p\\:graphicFrame',
      'a\\:graphic a\\:graphicData a\\:tbl',
      'p\\:sp[contains(@*, "table")]'
    ];
    
    for (const selector of tableSelectors) {
      const tables = doc.querySelectorAll(selector);
      if (tables.length > 0) {
        console.log(`üìä Found ${tables.length} tables with selector: ${selector}`);
        
        for (const table of tables) {
          const tableText = extractTableFromElement(table);
          if (tableText) return tableText;
        }
      }
    }
    
    // Alternative: Look for table-like structures in graphic frames
    const graphicFrames = doc.querySelectorAll('p\\:graphicFrame, graphicFrame');
    for (const frame of graphicFrames) {
      const tableData = extractTableFromGraphicFrame(frame);
      if (tableData) return tableData;
    }
    
    console.log("‚ùå No tables found in XML");
    return "";
    
  } catch (error) {
    console.log("‚ùå XML parsing error:", error);
    return "";
  }
}

function extractTableFromElement(tableElement: Element): string {
  // Multiple row detection strategies
  const rowSelectors = ['a\\:tr, tr', '[*|localName="tr"]', 'a\\:gridCol'];
  
  for (const rowSelector of rowSelectors) {
    const rows = tableElement.querySelectorAll(rowSelector);
    if (rows.length === 0) continue;
    
    let tableText = "";
    
    rows.forEach((row, rowIndex) => {
      const cellSelectors = ['a\\:tc, tc', '[*|localName="tc"]', 'a\\:t, t'];
      
      for (const cellSelector of cellSelectors) {
        const cells = row.querySelectorAll(cellSelector);
        if (cells.length === 0) continue;
        
        let rowText = "";
        cells.forEach((cell, cellIndex) => {
          const text = extractTextFromCell(cell);
          if (text) {
            rowText += text;
            if (cellIndex < cells.length - 1) rowText += "\t";
          }
        });
        
        if (rowText.trim()) {
          tableText += rowText;
          if (rowIndex < rows.length - 1) tableText += "\n";
        }
        break; // Found cells, no need to try other selectors
      }
    });
    
    if (tableText.trim()) {
      console.log("‚úÖ Table extracted from XML");
      return tableText;
    }
  }
  
  return "";
}

function extractTextFromCell(cellElement: Element): string {
  // Multiple text extraction approaches
  const textSelectors = [
    'a\\:t, t',
    '[*|localName="t"]',
    'a\\:p a\\:t',
    'p t',
    'a\\:r a\\:t'
  ];
  
  for (const selector of textSelectors) {
    const textElements = cellElement.querySelectorAll(selector);
    if (textElements.length > 0) {
      let cellText = "";
      textElements.forEach(el => {
        const text = el.textContent || el.innerHTML || "";
        if (text.trim()) cellText += text.trim() + " ";
      });
      if (cellText.trim()) return cellText.trim();
    }
  }
  
  // Fallback: direct text content
  const directText = cellElement.textContent || cellElement.innerHTML || "";
  return directText.trim();
}

function extractTableFromGraphicFrame(frame: Element): string {
  // Look for table data in graphic frame structures
  const tableData = frame.querySelector('a\\:graphic a\\:graphicData');
  if (tableData) {
    return extractTableFromElement(tableData);
  }
  return "";
}

// Method 2: COM Automation (if available in environment)
async function extractTableViaCOM(ctx: PowerPoint.RequestContext, shape: PowerPoint.Shape): Promise<string> {
  console.log("üîÑ Method 2: COM automation attempt");
  
  try {
    // This works only if PowerPoint COM objects are available
    // @ts-ignore - COM objects not in TypeScript definitions
    if (typeof ActiveXObject !== 'undefined') {
      const ppt = new ActiveXObject("PowerPoint.Application");
      const presentation = ppt.ActivePresentation;
      const slide = presentation.Slides(ppt.ActiveWindow.View.Slide.SlideIndex);
      
      // Find the table shape
      for (let i = 1; i <= slide.Shapes.Count; i++) {
        const shapeObj = slide.Shapes(i);
        if (shapeObj.HasTable) {
          const table = shapeObj.Table;
          let tableText = "";
          
          for (let row = 1; row <= table.Rows.Count; row++) {
            for (let col = 1; col <= table.Columns.Count; col++) {
              const cellText = table.Cell(row, col).Shape.TextFrame.TextRange.Text;
              tableText += cellText + (col < table.Columns.Count ? "\t" : "");
            }
            tableText += row < table.Rows.Count ? "\n" : "";
          }
          
          console.log("‚úÖ COM extraction successful");
          return tableText;
        }
      }
    }
  } catch (error) {
    console.log("‚ùå COM automation failed:", error);
  }
  
  return "";
}

// Method 3: Try undocumented Office.js properties
async function extractTableViaUndocumentedAPI(ctx: PowerPoint.RequestContext, shape: PowerPoint.Shape): Promise<string> {
  console.log("üîÑ Method 3: Undocumented API exploration");
  
  try {
    // Load everything possible on the shape
    shape.load();
    await ctx.sync();
    
    // Try accessing potential hidden table properties
    const hiddenProperties = ['_table', 'tableData', 'content', 'data', 'cells', 'rows', 'columns'];
    
    for (const prop of hiddenProperties) {
      if ((shape as any)[prop]) {
        console.log(`üìã Found hidden property: ${prop}`);
        const data = (shape as any)[prop];
        
        // Try to extract text from the hidden property
        if (typeof data === 'string') return data;
        if (data.text) return data.text;
        if (data.toString && typeof data.toString === 'function') {
          const text = data.toString();
          if (text !== '[object Object]') return text;
        }
      }
    }
    
    // Try accessing the shape's internal structure
    const shapeAny = shape as any;
    if (shapeAny._objectPath && shapeAny._objectPath._objectPathInfo) {
      console.log("üìã Exploring object path info");
      // This might contain internal references we can use
    }
    
  } catch (error) {
    console.log("‚ùå Undocumented API exploration failed:", error);
  }
  
  return "";
}

// Method 4: Binary/Raw data extraction approach
async function extractTableViaBinaryMethod(ctx: PowerPoint.RequestContext): Promise<string> {
  console.log("üîÑ Method 4: Binary extraction attempt");
  
  try {
    // Try to access presentation as binary data and extract table information
    // This is a long shot but worth trying
    
    // Get all slides and their content
    const slides = ctx.presentation.slides;
    slides.load("items");
    await ctx.sync();
    
    for (const slide of slides.items) {
      const shapes = slide.shapes;
      shapes.load("items");
      await ctx.sync();
      
      for (const shape of shapes.items) {
        shape.load("type,name");
        await ctx.sync();
        
        if (shape.type === "Table") {
          // Try to get any available text content through alternative means
          try {
            // Load all possible properties
            (shape as any).load("*");
            await ctx.sync();
            
            // Check if we can access the shape's XML directly
            if ((shape as any).xml) {
              const tableText = parseAdvancedTableXML((shape as any).xml);
              if (tableText) return tableText;
            }
            
          } catch (e) {
            console.log("Binary method shape processing failed");
          }
        }
      }
    }
    
  } catch (error) {
    console.log("‚ùå Binary extraction failed:", error);
  }
  
  return "";
}

// Helper function for regular text shapes
async function extractRegularTextShape(ctx: PowerPoint.RequestContext, shape: PowerPoint.Shape): Promise<string> {
  try {
    shape.load("textFrame");
    await ctx.sync();
    if (shape.textFrame) {
      shape.textFrame.load("textRange");
      await ctx.sync();
      if (shape.textFrame.textRange) {
        shape.textFrame.textRange.load("text");
        await ctx.sync();
        return shape.textFrame.textRange.text?.trim() || "";
      }
    }
  } catch (e) {
    console.log("Regular text extraction failed:", e);
  }
  return "";
}