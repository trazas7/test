/**
 * Extract all text-box shapes (`p:sp` with `a:txBody`) from a slide,
 * preserving hyperlinks using the slide’s .rels map.
 */
function extractTextShapesFromSlideXML(
  xml: string,
  slideNo: number,
  rels: Map<string, string>
): { slideNo: number; name: string; geom: EMUBox; text: string }[] {
  const doc = new DOMParser().parseFromString(xml, "application/xml");
  const shapes = Array.from(doc.getElementsByTagNameNS("*", "sp"));
  const out: { slideNo: number; name: string; geom: EMUBox; text: string }[] = [];

  for (const sp of shapes) {
    const nv = firstChildLocal(sp, "nvSpPr");
    const cNvPr = nv ? firstChildLocal(nv, "cNvPr") : null;
    const name = (cNvPr?.getAttribute("name") ?? "").toString();

    const xfrm = firstChildLocal(sp, "xfrm");
    const off = xfrm ? firstChildLocal(xfrm, "off") : null;
    const ext = xfrm ? firstChildLocal(xfrm, "ext") : null;

    const txBody = firstChildLocal(sp, "txBody"); // text lives here
    if (!off || !ext || !txBody) continue;

    const geom: EMUBox = {
      x: toNum(off.getAttribute("x")),
      y: toNum(off.getAttribute("y")),
      cx: toNum(ext.getAttribute("cx")),
      cy: toNum(ext.getAttribute("cy")),
    };

    const text = getTextFromTextBodyWithLinks(txBody, rels);
    out.push({ slideNo, name, geom, text });
  }
  return out;
}

/**
 * Read a `a:txBody` → paragraphs (`a:p`) → runs (`a:r`) and preserve links
 * (`a:rPr/a:hlinkClick @r:id`). Paragraphs are joined with `\n`.
 */
function getTextFromTextBodyWithLinks(txBody: Element, rels: Map<string, string>): string {
  const paras = Array.from(txBody.getElementsByTagNameNS("*", "p"));
  const lines: string[] = [];

  for (const p of paras) {
    const runs = Array.from(p.getElementsByTagNameNS("*", "r"));
    const parts: string[] = [];

    if (runs.length) {
      for (const r of runs) {
        const rPr = firstChildLocal(r, "rPr");
        let url: string | null = null;
        if (rPr) {
          const h = firstChildLocal(rPr, "hlinkClick");
          const rId =
            h?.getAttributeNS("http://schemas.openxmlformats.org/officeDocument/2006/relationships", "id") ||
            h?.getAttribute("r:id");
          if (rId) url = rels.get(rId) ?? null;
        }

        const tNodes = Array.from(r.getElementsByTagNameNS("*", "t"));
        let txt = tNodes.map((t) => t.textContent ?? "").join("");
        if (Array.from(r.getElementsByTagNameNS("*", "br")).length > 0) {
          txt = txt.replace(/\s{2,}/g, "\n");
        }
        txt = txt.trim();
        if (!txt) continue;

        parts.push(url ? formatLinkedText(txt, url) : txt);
      }
      lines.push(parts.join(" ").replace(/\s{2,}/g, " ").trim());
    } else {
      // paragraph without explicit runs — fallback walker
      const walker = p.ownerDocument!.createTreeWalker(
        p,
        NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT
      );
      let out = "";
      for (let n = walker.nextNode(); n; n = walker.nextNode()) {
        if (n.nodeType === Node.ELEMENT_NODE) {
          const el = n as Element;
          if (el.localName === "t") out += el.textContent ?? "";
          else if (el.localName === "br") out += "\n";
        }
      }
      lines.push(out.replace(/\s+\n/g, "\n").replace(/\n{3,}/g, "\n\n").trim());
    }
  }

  // Remove leading/trailing empty lines
  return lines.filter((l) => l && l.trim()).join("\n");
}






######

// --- TextBox (link-preserving) ---
const textShape = (ss.items as any[]).find((s) => s.type === "TextBox");
if (textShape) {
  // Geometry + name of the selected textbox
  const targetTB = toEMUBox({
    left: Number(textShape.left),
    top: Number(textShape.top),
    width: Number(textShape.width),
    height: Number(textShape.height),
  });
  const selectedTBName = normalize(String(textShape.name ?? ""));

  // Read PPTX → slides + .rels
  const zipBuffer = await getCompressedFile();
  const { entries } = await unzip(zipBuffer);
  const slidePaths = Object.keys(entries)
    .filter((p) => /^ppt\/slides\/slide\d+\.xml$/.test(p))
    .sort((a, b) => slideNo(a) - slideNo(b));

  // Collect all text shapes from all slides, then pick best by geometry+name
  const allTextShapes: { slideNo: number; name: string; geom: EMUBox; text: string }[] = [];
  for (const spath of slidePaths) {
    const sNo = slideNo(spath);
    const xml = await entries[spath].text();
    const relPath = `ppt/slides/_rels/slide${sNo}.xml.rels`;
    const relsMap = entries[relPath] ? await parseSlideRels(await entries[relPath].text()) : new Map();
    allTextShapes.push(...extractTextShapesFromSlideXML(xml, sNo, relsMap));
  }
  if (allTextShapes.length === 0) {
    throw new Error("No text shapes found on the slides.");
  }

  const rankedTB = allTextShapes
    .map((t) => {
      const g = geomScore(targetTB, t.geom);
      const namePenalty = normalize(t.name) === selectedTBName ? 0 : NAME_MISMATCH_PENALTY;
      return { ...t, score: g + namePenalty };
    })
    .sort((a, b) => a.score - b.score);

  const bestTB = rankedTB[0], secondTB = rankedTB[1];
  if (secondTB && bestTB.score + AMBIGUITY_MARGIN >= secondTB.score) {
    throw new Error("Ambiguous selection: multiple text boxes look identical. Nudge/resize or rename, then try again.");
  }

  // Return the link-preserved textbox content
  return bestTB.text.trim();
}



