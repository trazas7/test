// npm i jszip
import JSZip from "jszip";

/**
 * Selected text ‚Üí selected text box ‚Üí if a TABLE is selected,
 * parse ONLY that table on the active slide by matching the shape name.
 * Otherwise, (optionally) fall back to all slides.
 */
export async function getPptSelectedTextOrShape(): Promise<string> {
  const t0 = performance.now();
  console.log("üöÄ [getPptSelectedTextOrShape] start");

  let activeSlideIndex: number | null = null; // 1-based when available
  let selectedTableName: string | null = null;

  const immediateText = await PowerPoint.run(async (ctx) => {
    try {
      console.log("üîé step 1: try highlighted text");
      const sel = ctx.presentation.getSelectedTextRangeOrNullObject();
      await ctx.sync();
      if (!sel.isNullObject) {
        sel.load("text");
        await ctx.sync();
        const t = (sel.text ?? "").trim();
        console.log("üñ±Ô∏è selected text:", JSON.stringify(t));
        if (t) return t;
      }

      console.log("üîé step 2: inspect selected shapes");
      const shapes = ctx.presentation.getSelectedShapes();
      shapes.load("items");
      await ctx.sync();
      console.log("üì¶ selected shapes:", shapes.items.length);

      if (shapes.items.length > 0) {
        shapes.items.forEach((s) =>
          s.load("type,name,hasText,textFrame/textRange/text")
        );
        await ctx.sync();

        for (const s of shapes.items as any[]) {
          console.log(
            `‚Ä¢ shape name=${s.name} type=${s.type} hasText=${s.hasText}`
          );
          if (s.type === "TextBox" && s.textFrame?.textRange?.text?.trim()) {
            const txt = s.textFrame.textRange.text.trim();
            console.log("üìù returning textbox text");
            return txt;
          }
          if (s.type === "Table") {
            selectedTableName = s.name ?? null;
            console.log("üìä table selected; name:", selectedTableName);
          }
        }
      }

      try {
        const slide = ctx.presentation.slides.getActiveSlide();
        slide.load("index");
        await ctx.sync();
        activeSlideIndex = (slide as any).index ?? null;
        console.log("üìç active slide index:", activeSlideIndex);
      } catch (e) {
        console.log("‚ö†Ô∏è could not read active slide index:", e);
      }

      return "";
    } catch (err) {
      console.error("üí• error during selection scan:", err);
      return "";
    }
  });

  if (immediateText?.trim()) {
    console.log(
      `‚úÖ plain text path in ${Math.round(performance.now() - t0)} ms`
    );
    return immediateText.trim();
  }

  // ---- ZIP parsing, but now FILTER to only the selected table on the active slide ----
  console.log(
    "üß≠ going to ZIP parse with filters:",
    JSON.stringify({ activeSlideIndex, selectedTableName })
  );

  try {
    const tZip0 = performance.now();
    const tsv = await readPptTablesAsTSV({
      preferSlideIndex: activeSlideIndex,
      filterShapeName: selectedTableName, // << only this table
      fallbackAllSlides: false,           // << do NOT traverse whole deck by default
    });
    console.log(
      `üì¶ ZIP parse finished in ${Math.round(performance.now() - tZip0)} ms`
    );
    if (tsv.trim()) {
      console.log(
        `‚úÖ returning selected table TSV in ${Math.round(
          performance.now() - t0
        )} ms`
      );
      return tsv;
    }
    console.log("‚ùå no TSV found for the selected table/slide");
  } catch (zipErr) {
    console.error("üí• ZIP parse failed:", zipErr);
  }

  return "";
}

/* ------------------------------------------------------------------------------------------------
 * ZIP parsing with shape-name filter (matches <p:cNvPr name="‚Ä¶"> inside graphicFrame on the slide)
 * ------------------------------------------------------------------------------------------------*/

type ReadTablesOpts = {
  /** 1-based index of the active slide to read (strongly recommended) */
  preferSlideIndex?: number | null;
  /** If provided, only extract the table whose graphicFrame cNvPr@name equals this value */
  filterShapeName?: string | null;
  /** If true and preferred slide missing, parse all slides (not recommended for your case) */
  fallbackAllSlides?: boolean;
};

export async function readPptTablesAsTSV(
  opts: ReadTablesOpts = {}
): Promise<string> {
  const { preferSlideIndex = null, filterShapeName = null, fallbackAllSlides = false } =
    opts;

  console.log(
    "üîß [readPptTablesAsTSV] opts:",
    JSON.stringify({ preferSlideIndex, filterShapeName, fallbackAllSlides })
  );

  console.log("‚¨áÔ∏è fetching PPTX ZIP");
  const zipBuffer = await getPptxZipArrayBuffer();
  console.log("‚úÖ ZIP bytes:", (zipBuffer.byteLength / 1024).toFixed(1), "KB");

  console.log("üßµ unzipping...");
  const zip = await JSZip.loadAsync(zipBuffer);

  const slidePaths = Object.keys(zip.files)
    .filter((p) => /^ppt\/slides\/slide\d+\.xml$/.test(p))
    .sort((a, b) => {
      const na = parseInt(a.match(/slide(\d+)\.xml/)![1], 10);
      const nb = parseInt(b.match(/slide(\d+)\.xml/)![1], 10);
      return na - nb;
    });

  console.log("üìÑ slide XMLs:", slidePaths.length);

  let targets: string[] = slidePaths;
  if (preferSlideIndex) {
    const specific = slidePaths.filter((p) =>
      p.endsWith(`slide${preferSlideIndex}.xml`)
    );
    if (specific.length) {
      targets = specific;
      console.log("üéØ targeting only:", targets[0]);
    } else if (!fallbackAllSlides) {
      console.log("‚õî preferred slide not found; not falling back");
      return "";
    } else {
      console.log("‚Ü™Ô∏è preferred slide not found; falling back to all slides");
    }
  }

  let out: string[] = [];
  for (const path of targets) {
    console.log("üß© parse", path);
    const xmlText = await zip.files[path].async("text");
    const tsvBlocks = extractTablesFromSlideXML(xmlText, filterShapeName);
    console.log(
      `   üìä tables returned from ${path}:`,
      tsvBlocks.length,
      "(filtered by name:",
      filterShapeName,
      ")"
    );
    out.push(...tsvBlocks);
    // if we found the selected table, we can stop
    if (filterShapeName && tsvBlocks.length > 0) break;
  }

  const result = out.join("\n\n").trim();
  console.log("üßæ final TSV length:", result.length);
  return result;
}

/** stream the current presentation into memory as a ZIP ArrayBuffer */
async function getPptxZipArrayBuffer(): Promise<ArrayBuffer> {
  const file = await getFileAsync(Office.FileType.Compressed);
  console.log("üì¶ file acquired; slices:", file.sliceCount);
  try {
    const chunks: Uint8Array[] = [];
    for (let i = 0; i < file.sliceCount; i++) {
      const slice = await getSliceAsync(file, i);
      const u8 = new Uint8Array(slice.value.data as number[]);
      chunks.push(u8);
      if (i === 0 || i === file.sliceCount - 1 || (i + 1) % 10 === 0) {
        console.log(`   üîπ slice ${i + 1}/${file.sliceCount} (${u8.length} B)`);
      }
    }
    const total = chunks.reduce((s, u) => s + u.length, 0);
    console.log("üìè total bytes:", total);
    const merged = new Uint8Array(total);
    let off = 0;
    for (const u of chunks) {
      merged.set(u, off);
      off += u.length;
    }
    return merged.buffer;
  } finally {
    file.closeAsync(() => console.log("üßπ file closed"));
  }
}
function getFileAsync(type: Office.FileType): Promise<Office.File> {
  return new Promise((resolve, reject) => {
    Office.context.document.getFileAsync(type, (res) => {
      if (res.status === Office.AsyncResultStatus.Succeeded) resolve(res.value);
      else {
        console.error("‚ùå getFileAsync failed:", res.error);
        reject(res.error);
      }
    });
  });
}
function getSliceAsync(file: Office.File, index: number) {
  return new Promise<Office.AsyncResult<Office.Slice>>((resolve, reject) => {
    file.getSliceAsync(index, (res) => {
      if (res.status === Office.AsyncResultStatus.Succeeded) resolve(res);
      else {
        console.error(`‚ùå getSliceAsync(${index}) failed:`, res.error);
        reject(res.error);
      }
    });
  });
}

/* --------------------------- XML helpers (with filtering) --------------------------- */

/**
 * If filterShapeName is provided, find <p:graphicFrame> whose
 * <p:nvGraphicFramePr><p:cNvPr name="filterShapeName"> and extract its <a:tbl>.
 * Otherwise, extract all tables on the slide.
 */
function extractTablesFromSlideXML(
  xml: string,
  filterShapeName: string | null
): string[] {
  console.log(
    "üî¨ parse slide XML (length:",
    xml.length,
    ") filterShapeName=",
    filterShapeName
  );
  const doc = new DOMParser().parseFromString(xml, "application/xml");

  if (filterShapeName) {
    // Find the matching graphicFrame by cNvPr@name
    const frames = Array.from(doc.getElementsByTagNameNS("*", "graphicFrame"));
    console.log("üîé graphicFrame count:", frames.length);

    for (const gf of frames) {
      const nv = firstChildByLocalName(gf, "nvGraphicFramePr");
      const cNvPr = nv ? firstChildByLocalName(nv, "cNvPr") : null;
      const name = cNvPr?.getAttribute("name") ?? "";
      if (name === filterShapeName) {
        console.log("üéØ matched graphicFrame by name:", name);
        const graphic = firstChildByLocalName(gf, "graphic");
        const graphicData = graphic ? firstChildByLocalName(graphic, "graphicData") : null;
        const tbl = graphicData ? firstChildByLocalName(graphicData, "tbl") : null;
        if (!tbl) {
          console.log("‚ö†Ô∏è matched frame has no <tbl> inside");
          return [];
        }
        return [tableElementToTSV(tbl, 0)];
      }
    }
    console.log("‚ö†Ô∏è no graphicFrame matched by name; returning []");
    return [];
  }

  // no filter ‚Üí all tables on slide
  const tables: Element[] = [...Array.from(doc.getElementsByTagNameNS("*", "tbl"))];
  console.log("üîé <tbl> count:", tables.length);
  return tables.map((t, i) => tableElementToTSV(t, i)).filter((s) => s.trim());
}

function firstChildByLocalName(parent: Element, local: string): Element | null {
  for (let i = 0; i < parent.childNodes.length; i++) {
    const n = parent.childNodes[i];
    if (n.nodeType === Node.ELEMENT_NODE && (n as Element).localName === local) {
      return n as Element;
    }
  }
  return null;
}

/** Convert <a:tbl> to TSV and log cell contents */
function tableElementToTSV(tblEl: Element, tblIndex: number): string {
  const rows = Array.from(tblEl.getElementsByTagNameNS("*", "tr"));
  console.log(`üß± table#${tblIndex} rows:`, rows.length);

  const lines: string[] = [];
  for (let r = 0; r < rows.length; r++) {
    const tr = rows[r];
    const cells = Array.from(tr.getElementsByTagNameNS("*", "tc"));
    const vals = cells.map((tc, c) => {
      const t = getTextFromCell(tc);
      console.log(`   ‚Ä¢ r${r}c${c} text=`, JSON.stringify(t));
      return t;
    });

    // trim trailing empties
    let end = vals.length;
    while (end > 0 && (!vals[end - 1] || !vals[end - 1].trim())) end--;
    lines.push(vals.slice(0, end).join("\t"));
  }
  while (lines.length && !lines[lines.length - 1].trim()) lines.pop();

  const tsv = lines.join("\n");
  console.log(`üßæ table#${tblIndex} TSV length:`, tsv.length);
  return tsv;
}

function getTextFromCell(tc: Element): string {
  const doc = tc.ownerDocument!;
  const walker = doc.createTreeWalker(
    tc,
    NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT
  );

  let n: Node | null = walker.nextNode();
  let out = "";
  while (n) {
    if (n.nodeType === Node.ELEMENT_NODE) {
      const el = n as Element;
      if (el.localName === "t") out += el.textContent ?? "";
      else if (el.localName === "br") out += "\n";
    }
    n = walker.nextNode();
  }
  return out.replace(/\s+\n/g, "\n").replace(/\n{3,}/g, "\n\n").trim();
}