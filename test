async function getPptSelectedOrFullText(task: any): Promise<string> {
  return await PowerPoint.run(async (ctx) => {
    // -------- utilities --------
    async function logShapes(shapes: PowerPoint.ShapeCollection) {
      shapes.load("items");
      await ctx.sync();

      console.log("[DBG] selectedShapes.count:", shapes.items.length);
      shapes.items.forEach(s => s.load("id,name,type,textFrame/hasText,groupItems/items"));
      await ctx.sync();

      shapes.items.forEach((s: any, i: number) => {
        console.log(`[DBG] shape[${i}]`, {
          id: s.id,
          name: s.name,
          type: s.type,
          hasText: s.textFrame?.hasText,
          isGroup: !!s.groupItems
        });
      });
    }

    async function extractFromShapes(shapes: PowerPoint.ShapeCollection): Promise<string> {
      const out: string[] = [];

      // always make sure we have items
      shapes.load("items");
      await ctx.sync();

      // pre-load basic props used for branching
      shapes.items.forEach(s => s.load("type,textFrame/hasText,textFrame/textRange/text,groupItems/items"));
      await ctx.sync();

      async function walkShape(s: any) {
        // A) Text box
        if (s.textFrame?.hasText && s.textFrame?.textRange?.text) {
          const t = (s.textFrame.textRange.text || "").trim();
          if (t) out.push(t);
        }

        // B) Table (use getCount() — NOT load(".../count"))
        if (s.type === "Table" || s.table) {
          let rows = 0, cols = 0;
          try {
            rows = s.table.rows.getCount();
            cols = s.table.columns.getCount();
            await ctx.sync();
            console.log(`[DBG] Table detected: ${rows} rows x ${cols} cols`);
          } catch (e) {
            console.warn("[DBG] Could not get table counts:", e);
          }

          // load all cells' text
          for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
              const cell = s.table.getCell(r, c);
              cell.load("textFrame/hasText,textFrame/textRange/text");
            }
          }
          await ctx.sync();

          for (let r = 0; r < rows; r++) {
            const rowTexts: string[] = [];
            for (let c = 0; c < cols; c++) {
              const cell: any = s.table.getCell(r, c);
              const txt = cell.textFrame?.hasText ? (cell.textFrame.textRange.text || "") : "";
              rowTexts.push(txt.trim());
            }
            out.push(rowTexts.join("\t"));
          }
        }

        // C) Group → recurse
        if (s.groupItems) {
          s.groupItems.load("items");
          await ctx.sync();
          for (const child of s.groupItems.items as any[]) {
            child.load("type,textFrame/hasText,textFrame/textRange/text,groupItems/items");
          }
          await ctx.sync();
          for (const child of s.groupItems.items as any[]) {
            await walkShape(child);
          }
        }
      }

      for (const s of shapes.items as any[]) {
        try {
          await walkShape(s);
        } catch (e) {
          console.warn("[DBG] walkShape failed for shape:", s?.name || s?.id, e);
        }
      }

      return out.filter(Boolean).join("\n");
    }

    // -------- 1) SHAPES FIRST (prevents table exception) --------
    const selShapes = ctx.presentation.getSelectedShapes();
    try {
      await logShapes(selShapes);
      const fromShapes = await extractFromShapes(selShapes);
      if (fromShapes) {
        console.log("[DBG] Using text extracted from shapes.");
        return fromShapes;
      }
    } catch (e) {
      console.warn("[DBG] Shape inspection/extraction failed:", e);
    }

    // -------- 2) TEXT RANGE (only if shapes yielded nothing) --------
    try {
      const selRange = ctx.presentation.getSelectedTextRange();
      selRange.load("text");
      await ctx.sync();
      const selTxt = (selRange.text ?? "").trim();
      console.log("[DBG] selectedTextRange:", JSON.stringify(selTxt));
      if (selTxt) {
        console.log("[DBG] Using selected text");
        return selTxt;
      }
    } catch (e) {
      console.warn("[DBG] getSelectedTextRange threw (likely table selected):", e);
    }

    // -------- 3) FALLBACK --------
    if (!task.shouldSelectText && task.name !== "AD_HOC") {
      console.log("[DBG] Falling back to collectAllSlidesText");
      try {
        return await collectAllSlidesText(ctx);
      } catch (e) {
        console.warn("[DBG] collectAllSlidesText failed:", e);
      }
    }

    console.log("[DBG] No usable selection.");
    return "";
  });
}