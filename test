// Gets the user's selected text if any; otherwise the text content of the selected shape(s)
// (text boxes/placeholders/tables/groups). Works with older typings by using `any`
// only for members that some d.ts files don’t declare yet (Table, Group).
export async function getPptSelectedTextOrShape(): Promise<string> {
  return PowerPoint.run(async (ctx) => {
    const pres = ctx.presentation;

    // ---- 1) Prefer an active text selection (also works in table cells) ----
    const sel = pres.getSelectedTextRangeOrNullObject();
    await ctx.sync();
    if (!sel.isNullObject) {
      sel.load("text");
      await ctx.sync();
      return (sel.text ?? "").trim();
    }

    // ---- 2) Otherwise read from the selected shape(s) ----
    const selected = pres.getSelectedShapes();
    // Load the minimal info we need up front (type + textFrame bits).
    selected.load("items");
    await ctx.sync();
    // Load each shape’s type and text info in one round-trip.
    selected.items.forEach(s =>
      s.load("type,textFrame/hasText,textFrame/textRange/text")
    );
    await ctx.sync();
    if (selected.items.length === 0) return "";

    const parts: string[] = [];

    // Helper: join a 2D array into lines/tabs.
    const join2D = (vals: any[][]) =>
      vals.map(row => row.map(v => v ?? "").join("\t")).join("\n").trim();

    // Helper: read all text from a Table. Uses fast .values, falls back to cells.
    const tableToText = async (tbl: any): Promise<string> => {
      tbl.load("values,rowCount,columnCount");
      await ctx.sync();

      if (Array.isArray(tbl.values)) {
        return join2D(tbl.values);
      }

      const rows = Number(tbl.rowCount) || 0;
      const cols = Number(tbl.columnCount) || 0;
      const loadedCells: { r: number; c: number; cell: any }[] = [];

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const cell = tbl.getCellOrNullObject(r, c);
          cell.load("text,isNullObject");
          loadedCells.push({ r, c, cell });
        }
      }
      await ctx.sync();

      const grid: string[][] = Array.from({ length: rows }, () => Array(cols).fill(""));
      for (const { r, c, cell } of loadedCells) {
        grid[r][c] = !cell.isNullObject ? (cell.text ?? "") : "";
      }
      return join2D(grid);
    };

    // Recursive collector (handles groups)
    const collectFromShapes = async (shapes: any): Promise<void> => {
      // We already loaded type/text for top-level; for nested groups we need to load again.
      if (shapes !== selected) {
        shapes.load("items");
        await ctx.sync();
        shapes.items.forEach((s: any) =>
          s.load("type,textFrame/hasText,textFrame/textRange/text")
        );
        await ctx.sync();
      }

      const nextGroups: any[] = [];
      const tables: any[] = [];

      for (const s of shapes.items) {
        // Text-bearing shapes
        if (s.textFrame?.hasText && s.textFrame?.textRange?.text) {
          const t = String(s.textFrame.textRange.text).trim();
          if (t) parts.push(t);
        }

        // Tables (works even if s.type might be 'Unsupported' on some builds)
        if (typeof (s as any).getTable === "function" ||
            String(s.type ?? "").toLowerCase() === "table") {
          tables.push((s as any).getTable());
        }

        // Groups
        const inner = (s as any).group?.shapes;
        if (inner) nextGroups.push(inner);
      }

      // Read all tables found at this level.
      for (const tbl of tables) {
        const t = (await tableToText(tbl)).trim();
        if (t) parts.push(t);
      }

      // Recurse into groups
      for (const g of nextGroups) {
        await collectFromShapes(g);
      }
    };

    await collectFromShapes(selected);
    return parts.join("\n\n");
  });
}
