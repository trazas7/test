/**
 * Walks the entire presentation and returns all textual content as a single string.
 *  - Slides → Shapes (with recursion into Groups)
 *  - TextFrames (text boxes, placeholders, callouts, most geometric shapes)
 *  - Tables (uses .values when available, falls back to cell-by-cell)
 *  - Optional: speaker notes (includeNotes: true)
 *
 * Lots of console logs prefixed with [ppt-dump] to help debug.
 */
export async function dumpWholeDeckText(opts?: { includeNotes?: boolean }): Promise<string> {
  const includeNotes = !!opts?.includeNotes;

  return PowerPoint.run(async (context) => {
    const t0 = Date.now();
    const log = (...a: any[]) => console.log("[ppt-dump]", ...a);

    const slides = context.presentation.slides;
    slides.load("items/id,index,name");
    await context.sync();

    log(`slides: ${slides.items.length}`);

    const deckParts: string[] = [];

    for (const slide of slides.items) {
      const header = `# Slide ${slide.index + 1}${slide.name ? ` — ${slide.name}` : ""}`;
      const slideParts: string[] = [header];

      // load shapes for the slide
      const shapes = slide.shapes;
      // NOTE: we load ids, names, & types up front; TextFrame/Table details are loaded per kind below.
      shapes.load("items/id,name,type");
      await context.sync();

      log("visit slide", { index: slide.index, id: slide.id, shapes: shapes.items.length });

      // collect text from shapes on the slide (recurses into groups)
      await collectFromShapeCollection(shapes, slideParts, context, log, "slide");

      // speaker notes (optional)
      if (includeNotes) {
        try {
          const notesPage = (slide as any).notesPage; // exposed in newer API sets
          if (notesPage?.shapes) {
            notesPage.shapes.load("items/id,name,type");
            await context.sync();

            const notesParts: string[] = [];
            await collectFromShapeCollection(notesPage.shapes, notesParts, context, log, "notes");
            if (notesParts.length) {
              slideParts.push("Notes:");
              slideParts.push(notesParts.join("\n"));
            }
          }
        } catch (e) {
          log("notes read failed", e);
        }
      }

      deckParts.push(slideParts.join("\n"));
    }

    const result = deckParts.join("\n\n----\n\n");
    log("done", { slides: slides.items.length, length: result.length, ms: Date.now() - t0 });
    return result;
  });
}

/**
 * Recursively collect text from a ShapeCollection/ShapeScopedCollection.
 *   - For text-capable shapes, reads TextFrame.textRange.text
 *   - For tables, first tries table.values; if not available, falls back to cell-by-cell
 *   - For groups, recurses into group.shapes
 *
 * Emits detailed logs for each branch so you can see why text was/wasn't collected.
 */
async function collectFromShapeCollection(
  scoped: PowerPoint.ShapeCollection | PowerPoint.ShapeScopedCollection,
  parts: string[],
  ctx: PowerPoint.RequestContext,
  log: (...args: any[]) => void,
  where: "slide" | "notes" | "group"
) {
  // We already loaded id/name/type on the collection before calling this in the top level.
  // But callers might pass a nested ShapeScopedCollection (group.shapes). Load again defensively.
  scoped.load("items/id,name,type");
  await ctx.sync();

  // batch readers
  const textFrames: { id: string; tf: PowerPoint.TextFrame }[] = [];
  const tables: { id: string; tbl: PowerPoint.Table }[] = [];
  const groups: PowerPoint.ShapeScopedCollection[] = [];

  for (const shape of (scoped as any).items as PowerPoint.Shape[]) {
    log("shape", { where, id: shape.id, name: shape.name, type: shape.type });

    // group: recurse later
    if (shape.type === PowerPoint.ShapeType.group) {
      try {
        groups.push(shape.group.shapes);
      } catch (e) {
        log("group access failed", { id: shape.id, e });
      }
      continue;
    }

    // table: gather for batch load
    if (shape.type === PowerPoint.ShapeType.table) {
      try {
        tables.push({ id: String(shape.id), tbl: shape.getTable() });
      } catch (e) {
        log("getTable failed", { id: shape.id, e });
      }
      continue;
    }

    // everything else that *can* have text: use safe getter
    try {
      const tf = shape.getTextFrameOrNullObject();  // safe per docs
      tf.load("hasText,textRange/text");
      textFrames.push({ id: String(shape.id), tf });
    } catch (e) {
      log("getTextFrameOrNullObject failed", { id: shape.id, e });
    }
  }

  // load the batch of text frames
  if (textFrames.length) {
    await ctx.sync();
    for (const { id, tf } of textFrames) {
      if (!(tf as any).isNullObject && tf.hasText && tf.textRange && typeof tf.textRange.text === "string") {
        const t = (tf.textRange.text || "").trim();
        if (t) {
          parts.push(t);
          log("text", { where, id, len: t.length });
        } else {
          log("text empty", { where, id });
        }
      }
    }
  }

  // load the batch of tables
  if (tables.length) {
    try {
      for (const j of tables) j.tbl.load("values,rowCount,columnCount");
      await ctx.sync();

      for (const { id, tbl } of tables) {
        let pushed = false;
        try {
          if (Array.isArray((tbl as any).values)) {
            const text = (tbl as any).values
              .map((row: string[]) => row.map(v => (v ?? "").trim()).join("\t"))
              .join("\n")
              .trim();
            if (text) {
              parts.push(text);
              pushed = true;
              log("table(values)", { where, id, rows: tbl.rowCount, cols: tbl.columnCount });
            }
          }
        } catch {
          // fall through
        }

        if (!pushed && typeof tbl.rowCount === "number" && typeof tbl.columnCount === "number") {
          const rows: string[] = [];
          for (let r = 0; r < tbl.rowCount; r++) {
            const rowVals: string[] = [];
            for (let c = 0; c < tbl.columnCount; c++) {
              const cell = tbl.getCellOrNullObject(r, c);
              cell.load("text");
            }
            await ctx.sync(); // load this row’s cells
            for (let c = 0; c < tbl.columnCount; c++) {
              const cell = tbl.getCellOrNullObject(r, c);
              rowVals.push((cell.text ?? "").trim());
            }
            rows.push(rowVals.join("\t"));
          }
          const t = rows.join("\n").trim();
          if (t) {
            parts.push(t);
            log("table(cells)", { where, id, rows: tbl.rowCount, cols: tbl.columnCount });
          } else {
            log("table empty", { where, id });
          }
        }
      }
    } catch (e) {
      log("table read failed", e);
    }
  }

  // recurse into groups last
  for (const inner of groups) {
    await collectFromShapeCollection(inner, parts, ctx, log, "group");
  }
}
