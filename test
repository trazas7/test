/**
 * ===== Tiny helpers =====
 */

// WORD: selection first; if task doesn't require a selection, fall back to whole body.
async function getWordText(task) {
  return Word.run(async (context) => {
    const sel = context.document.getSelection();
    sel.load("text");
    await context.sync();
    const selected = (sel.text || "").trim();
    if (selected) return selected;

    if (!task.shouldSelectText) {
      const body = context.document.body;
      body.load("text");
      await context.sync();
      return (body.text || "").trim();
    }
    return "";
  });
}

// POWERPOINT: selection → selected shapes (incl. tables) → whole deck (if allowed).
async function getPowerPointText(task) {
  return PowerPoint.run(async (context) => {
    // 0) Try direct text selection
    const tr = context.presentation.getSelectedTextRange();
    tr.load("text");
    await context.sync();
    const direct = (tr.text || "").trim();
    if (direct) return direct;

    const supports13 = Office.context.requirements.isSetSupported("PowerPointApi", "1.3");

    // 1) Selected shapes (covers tables & text frames)
    if (supports13) {
      const selectedShapes = context.presentation.getSelectedShapes();
      const fromSelected = await collectFromShapeCollection(context, selectedShapes);
      if (fromSelected) return fromSelected;
    }

    // 2) Whole deck (only if selection isn't required)
    if (!task.shouldSelectText && supports13) {
      return await collectFromAllSlides(context);
    }

    return "";
  });
}

/**
 * Collects text from a ShapeCollection (selected shapes). Safe guards avoid InvalidArgument.
 */
async function collectFromShapeCollection(context, shapeCollection) {
  shapeCollection.load("items");
  await context.sync();
  if (!shapeCollection.items.length) return "";

  // Stage A: discover what each shape actually has
  shapeCollection.items.forEach(sh => sh.load("textFrame,table"));
  await context.sync();

  // Stage B: for shapes with textFrame/table, load deeper data
  shapeCollection.items.forEach(sh => {
    if (sh.textFrame) sh.textFrame.load("hasText");
    if (sh.table) sh.table.rows.load("items");
  });
  await context.sync();

  // Stage C: table rows -> cells (only on actual tables)
  shapeCollection.items.forEach(sh => {
    if (sh.table) sh.table.rows.items.forEach(r => r.cells.load("items"));
  });
  await context.sync();

  // Stage D: now we can safely load text on things we know exist
  shapeCollection.items.forEach(sh => {
    if (sh.textFrame && sh.textFrame.hasText) sh.textFrame.textRange.load("text");
    if (sh.table) {
      sh.table.rows.items.forEach(r => {
        r.cells.items.forEach(c => {
          if (c.textFrame) c.textFrame.textRange.load("text");
        });
      });
    }
  });
  await context.sync();

  // Collect
  let out = "";
  for (const sh of shapeCollection.items) {
    if (sh.textFrame && sh.textFrame.hasText) {
      const t = (sh.textFrame.textRange.text || "").trim();
      if (t) out += t + "\n";
    }
    if (sh.table) {
      for (const r of sh.table.rows.items) {
        for (const c of r.cells.items) {
          const t = (c.textFrame && c.textFrame.textRange.text || "").trim();
          if (t) out += t + "\n";
        }
      }
    }
  }
  return out.trim();
}

/**
 * Collects text from every slide (all shapes + all table cells).
 */
async function collectFromAllSlides(context) {
  const slides = context.presentation.slides;
  slides.load("items");
  await context.sync();
  if (!slides.items.length) return "";

  // Load shapes on each slide
  slides.items.forEach(s => s.shapes.load("items"));
  await context.sync();

  // Probe textFrame/table
  slides.items.forEach(s => {
    s.shapes.items.forEach(sh => sh.load("textFrame,table"));
  });
  await context.sync();

  // Load deeper data for those that actually have it
  slides.items.forEach(s => {
    s.shapes.items.forEach(sh => {
      if (sh.textFrame) sh.textFrame.load("hasText");
      if (sh.table) sh.table.rows.load("items");
    });
  });
  await context.sync();

  slides.items.forEach(s => {
    s.shapes.items.forEach(sh => {
      if (sh.table) sh.table.rows.items.forEach(r => r.cells.load("items"));
    });
  });
  await context.sync();

  slides.items.forEach(s => {
    s.shapes.items.forEach(sh => {
      if (sh.textFrame && sh.textFrame.hasText) sh.textFrame.textRange.load("text");
      if (sh.table) {
        sh.table.rows.items.forEach(r => {
          r.cells.items.forEach(c => {
            if (c.textFrame) c.textFrame.textRange.load("text");
          });
        });
      }
    });
  });
  await context.sync();

  // Collect
  let out = "";
  for (const s of slides.items) {
    for (const sh of s.shapes.items) {
      if (sh.textFrame && sh.textFrame.hasText) {
        const t = (sh.textFrame.textRange.text || "").trim();
        if (t) out += t + "\n";
      }
      if (sh.table) {
        for (const r of sh.table.rows.items) {
          for (const c of r.cells.items) {
            const t = (c.textFrame && c.textFrame.textRange.text || "").trim();
            if (t) out += t + "\n";
          }
        }
      }
    }
  }
  return out.trim();
}

/**
 * ===== DROP-IN BUTTON METHOD =====
 */
function setupButtons() {
  for (const buttonId in TASK_CONFIG) {
    const el = document.getElementById(buttonId);
    if (!el) continue;

    el.addEventListener("click", async () => {
      try {
        const task = TASK_CONFIG[buttonId];
        currentTask = task.name;

        let text = "";
        if (Office.context.host === Office.HostType.Word) {
          text = await getWordText(task);
        } else if (Office.context.host === Office.HostType.PowerPoint) {
          text = await getPowerPointText(task);
        } else {
          showMessage("Supported in Word and PowerPoint only.", "error");
          return;
        }

        if (!text && task.shouldSelectText) {
          // Covers: whole slide selected, no shapes, or APIs not supported
          showMessage("Please select text or a table in the slide.", "error");
          return;
        }

        const prompt = text ? (task.prompt ? `${task.prompt}\n${text}` : text) : null;

        showPromptScreen({
          heading: task.heading,
          prompt,
          name: task.name,
          skipPromptReview: task.skipPromptReview
        });
      } catch (e) {
        console.error(e);
        showMessage("Error retrieving text. Try a smaller selection or another slide.", "error");
      }
    });
  }
}
