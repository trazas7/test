// Read the user's selection from PowerPoint:
// 1) If there's active text selection -> return it.
// 2) Else return concatenated text from selected shape(s):
//    - text boxes/placeholders (via TextFrame)
//    - tables (via getTable() + cells text)
//    - groups (recursively)
//
// NOTE: uses `any` for members some typings don't expose (Table, group).
export async function getPptSelectedTextOrShape(): Promise<string> {
  return PowerPoint.run(async (ctx) => {
    const log = (...a: any[]) => console.log("[getPptSelectedTextOrShape]", ...a);

    // -------- 1) Prefer active text selection --------
    const sel = ctx.presentation.getSelectedTextRangeOrNullObject();
    await ctx.sync();
    if (!sel.isNullObject) {
      sel.load("text");
      await ctx.sync();
      const t = (sel.text ?? "").trim();
      log("Active text selection found. length =", t.length);
      return t;
    }
    log("No active text selection.");

    const parts: string[] = [];

    // ---------- helpers ----------
    const join2D = (vals: string[][]) =>
      vals.map(r => r.join("\t")).join("\n").trim();

    // Read a *table shape* to plain text (tab-delimited, newline per row)
    const tableToText = async (shape: any, where: string) => {
      try {
        const table = shape.getTable(); // throws if it's not a table
        table.load("rowCount,columnCount");
        await ctx.sync();

        const rows = Number(table.rowCount) || 0;
        const cols = Number(table.columnCount) || 0;
        log(`${where}: table detected ${rows}x${cols}`);

        // Load all cells in a single round-trip
        const cells: { r: number; c: number; cell: any }[] = [];
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            const cell = table.getCellOrNullObject(r, c);
            cell.load("text,isNullObject");
            cells.push({ r, c, cell });
          }
        }
        await ctx.sync();

        const grid: string[][] = Array.from({ length: rows }, () => Array(cols).fill(""));
        for (const { r, c, cell } of cells) {
          grid[r][c] = !cell.isNullObject && typeof cell.text === "string" ? cell.text : "";
        }
        const text = join2D(grid);
        log(`${where}: table text length =`, text.length);
        if (text) parts.push(text);
      } catch (err) {
        log(`${where}: getTable() failed`, err);
      }
    };

    // Walk a ShapeScopedCollection (handles nested groups)
    const walk = async (shapes: any, path: string) => {
      shapes.load("items");
      await ctx.sync();
      log(`${path}: count =`, shapes.items.length);
      if (shapes.items.length === 0) return;

      // Load type + textframe metadata for this batch
      shapes.items.forEach((s: any) =>
        s.load("type,name,textFrame/hasText,textFrame/textRange/text")
      );
      await ctx.sync();

      let idx = 0;
      const groups: any[] = [];
      const tables: { shape: any; where: string }[] = [];

      for (const s of shapes.items) {
        const where = `${path}[${idx}]`;
        log(`${where}: type =`, s.type, "name =", s.name ?? "");

        // 1) Any textFrame text?
        if (s.textFrame?.hasText && s.textFrame?.textRange?.text) {
          const t = String(s.textFrame.textRange.text).trim();
          log(`${where}: textFrame length =`, t.length);
          if (t) parts.push(t);
        }

        // 2) Table: don’t rely only on type — try getTable() guarded
        if (s.type === PowerPoint.ShapeType.table || typeof (s as any).getTable === "function") {
          tables.push({ shape: s, where });
        }

        // 3) Group: recurse
        const inner = (s as any).group?.shapes;
        if (inner) {
          log(`${where}: group -> descending`);
          groups.push({ inner, where: where + ".group" });
        }

        idx++;
      }

      // Read any tables found in this batch
      for (const t of tables) {
        await tableToText(t.shape, t.where);
      }

      // Recurse into groups
      for (const g of groups) {
        await walk(g.inner, g.where);
      }
    };

    // Start from currently selected shapes
    const selected = ctx.presentation.getSelectedShapes();
    await walk(selected, "selected");

    const result = parts.join("\n\n");
    log("DONE. Final text length =", result.length);
    return result;
  });
}
