/**
 * Collect ALL visible text in the deck.
 * - slide.shapes → groups → textFrames + tables
 * - slide.layout.shapes (placeholders/footers on the layout)
 * - slide.master.shapes  (footers, logos, legal text on master)
 * - optional slide notes
 *
 * Very verbose logs: search for [ppt-dump] in DevTools.
 */
export async function dumpAllTextFromDeck(opts?: { includeNotes?: boolean }): Promise<string> {
  const includeNotes = !!opts?.includeNotes;

  return PowerPoint.run(async (context) => {
    const log = (...a: any[]) => console.log("[ppt-dump]", ...a);
    const slides = context.presentation.slides;

    slides.load("items/id,index,name");
    await context.sync();
    log("slides", slides.items.length);

    const deckOut: string[] = [];

    for (const slide of slides.items) {
      const slideHeader = `# Slide ${slide.index + 1}${slide.name ? ` — ${slide.name}` : ""}`;
      const parts: string[] = [slideHeader];

      // 1) Slide’s own shapes
      await collectFromAnyShapes(slide.shapes, parts, context, log, `slide ${slide.index + 1}`);

      // 2) Layout shapes (content inherited from layout)
      try {
        if ((slide as any).layout?.shapes) {
          log("layout", { slide: slide.index + 1 });
          await collectFromAnyShapes((slide as any).layout.shapes, parts, context, log, `layout ${slide.index + 1}`);
        }
      } catch (e) {
        log("layout read error", { slide: slide.index + 1, e });
      }

      // 3) Master shapes (footers etc.)
      try {
        if ((slide as any).master?.shapes) {
          log("master", { slide: slide.index + 1 });
          await collectFromAnyShapes((slide as any).master.shapes, parts, context, log, `master ${slide.index + 1}`);
        }
      } catch (e) {
        log("master read error", { slide: slide.index + 1, e });
      }

      // 4) Notes (optional)
      if (includeNotes) {
        try {
          const notes = (slide as any).notesPage;
          if (notes?.shapes) {
            const notesParts: string[] = [];
            await collectFromAnyShapes(notes.shapes, notesParts, context, log, `notes ${slide.index + 1}`);
            if (notesParts.length) {
              parts.push("Notes:");
              parts.push(notesParts.join("\n"));
            }
          }
        } catch (e) {
          log("notes read error", { slide: slide.index + 1, e });
        }
      }

      deckOut.push(parts.join("\n"));
    }

    const result = deckOut.join("\n\n----\n\n");
    log("done", { length: result.length });
    return result;
  });
}

/**
 * Collects text from a shape collection:
 * - loads ids/names/types and textFrame
 * - pushes text for any frame (even when hasText=false but textRange has content)
 * - reads tables (values → cells)
 * - recurses into groups
 */
async function collectFromAnyShapes(
  collection: PowerPoint.ShapeCollection | PowerPoint.ShapeScopedCollection,
  out: string[],
  ctx: PowerPoint.RequestContext,
  log: (...args: any[]) => void,
  where: string
) {
  // Load what we need up-front (CRITICAL)
  collection.load(
    "count," +
    "items/id,name,type," +
    "items/textFrame/hasText," +
    "items/textFrame/textRange/text"
  );
  await ctx.sync();

  log("shapes", { where, count: (collection as any).count });

  const items = (collection as any).items as PowerPoint.Shape[];
  let pushedText = 0;

  // 1) Text frames (eager)
  for (const shape of items) {
    const type = (shape as any).type;
    const id = shape.id;
    const name = (shape as any).name;
    // try eager text first
    try {
      const tf = (shape as any).textFrame as PowerPoint.TextFrame | undefined;
      if (tf && tf.textRange && typeof tf.textRange.text === "string") {
        const txt = (tf.textRange.text || "").trim();
        if (txt) {
          out.push(txt);
          pushedText++;
          continue;
        }
      }
    } catch { /* fall through */ }

    // fallback: safe getter even if hasText was false or textFrame missing in load
    try {
      const safe = shape.getTextFrameOrNullObject();
      safe.load("hasText,textRange/text");
      await ctx.sync();
      if (!(safe as any).isNullObject && safe.textRange && typeof safe.textRange.text === "string") {
        const txt = (safe.textRange.text || "").trim();
        if (txt) {
          out.push(txt);
          pushedText++;
        }
      }
    } catch (e) {
      log("textFrame fallback error", { where, id, e });
    }
  }
  log("text", { where, pushed: pushedText });

  // 2) Tables (batch)
  const tableJobs: { id: string; tbl: PowerPoint.Table }[] = [];
  for (const shape of items) {
    if ((shape as any).type === PowerPoint.ShapeType.table) {
      try { tableJobs.push({ id: String(shape.id), tbl: shape.getTable() }); }
      catch (e) { log("getTable error", { where, id: shape.id, e }); }
    }
  }
  if (tableJobs.length) {
    for (const j of tableJobs) j.tbl.load("values,rowCount,columnCount");
    await ctx.sync();

    for (const { id, tbl } of tableJobs) {
      let pushed = false;
      try {
        const vals = (tbl as any).values as string[][] | undefined;
        if (Array.isArray(vals)) {
          const text = vals.map(r => r.map(v => (v ?? "").trim()).join("\t")).join("\n").trim();
          if (text) { out.push(text); pushed = true; log("table(values)", { where, id, rows: tbl.rowCount, cols: tbl.columnCount }); }
        }
      } catch { /* fall back */ }

      if (!pushed && typeof tbl.rowCount === "number" && typeof tbl.columnCount === "number") {
        const rows: string[] = [];
        for (let r = 0; r < tbl.rowCount; r++) {
          // load all cells in row, then read
          for (let c = 0; c < tbl.columnCount; c++) tbl.getCellOrNullObject(r, c).load("text");
          await ctx.sync();
          const row: string[] = [];
          for (let c = 0; c < tbl.columnCount; c++) row.push((tbl.getCellOrNullObject(r, c).text ?? "").trim());
          rows.push(row.join("\t"));
        }
        const t = rows.join("\n").trim();
        if (t) { out.push(t); log("table(cells)", { where, rows: tbl.rowCount, cols: tbl.columnCount }); }
      }
    }
  }

  // 3) Groups (recurse)
  const groups: PowerPoint.ShapeScopedCollection[] = [];
  for (const shape of items) {
    if ((shape as any).type === PowerPoint.ShapeType.group) {
      try { groups.push(shape.group.shapes); }
      catch (e) { log("group error", { where, id: shape.id, e }); }
    }
  }
  for (const g of groups) {
    await collectFromAnyShapes(g, out, ctx, log, `${where}::group`);
  }
}
