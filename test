export async function getPptSelectedTextOrShape(): Promise<string> {
  console.log("🚀 Starting getPptSelectedTextOrShape function");
  
  return PowerPoint.run(async (ctx) => {
    console.log("📝 PowerPoint.run context initialized");
    
    try {
      // 1) Try highlighted text first
      console.log("🔍 Step 1: Checking for selected text range");
      const sel = ctx.presentation.getSelectedTextRangeOrNullObject();
      await ctx.sync();
      console.log("✅ Text range sync completed, checking if null object");
      
      if (!sel.isNullObject) {
        console.log("📖 Text range found, loading text content");
        sel.load("text");
        await ctx.sync();
        console.log("📄 Selected text:", sel.text);
        const textResult = (sel.text ?? "").trim();
        if (textResult) {
          console.log("✅ Returning selected text:", textResult);
          return textResult;
        }
      } else {
        console.log("❌ No text range selected");
      }

      // 2) Fallback: check if shapes are selected
      console.log("🔍 Step 2: Checking for selected shapes");
      const shapes = ctx.presentation.getSelectedShapes();
      shapes.load("items");
      await ctx.sync();
      console.log(`📊 Found ${shapes.items.length} selected shapes`);

      if (shapes.items.length > 0) {
        for (let i = 0; i < shapes.items.length; i++) {
          const shape = shapes.items[i];
          console.log(`🔍 Processing shape ${i + 1}/${shapes.items.length}`);
          
          // Load basic shape properties
          console.log("🔧 Loading shape properties...");
          shape.load("type,name,id");
          await ctx.sync();
          
          console.log(`📋 Shape type: "${shape.type}"`);
          console.log(`📋 Shape name: "${shape.name}"`);
          console.log(`📋 Shape id: "${shape.id}"`);
          
          // Check what properties are available
          console.log("🔍 Checking available shape properties...");
          try {
            // Try to load all possible properties to see what's available
            shape.load("textFrame,table,hasTable");
            await ctx.sync();
            console.log("✅ Additional properties loaded successfully");
            
            // Log what we found
            console.log(`📋 Has textFrame: ${!!shape.textFrame}`);
            console.log(`📋 Has table property: ${!!shape.table}`);
            console.log(`📋 Has hasTable property: ${!!(shape as any).hasTable}`);
            
          } catch (loadError) {
            console.warn("⚠️ Error loading additional properties:", loadError);
          }

          // Try different approaches based on shape type
          if (shape.type === "Table") {
            console.log("🏗️ Detected table shape, attempting table extraction...");
            try {
              const tableText = await attemptTableExtraction(shape, ctx);
              if (tableText) {
                console.log("✅ Table extraction successful:", tableText);
                return tableText;
              }
            } catch (tableError) {
              console.error("❌ Table extraction failed:", tableError);
            }
          }
          
          // Try text frame approach (original logic)
          if (shape.textFrame) {
            console.log("📝 Shape has textFrame, checking for text...");
            try {
              shape.textFrame.load("hasText,textRange");
              await ctx.sync();
              console.log(`📋 TextFrame hasText: ${shape.textFrame.hasText}`);
              
              if (shape.textFrame.hasText && shape.textFrame.textRange) {
                shape.textFrame.textRange.load("text");
                await ctx.sync();
                const text = shape.textFrame.textRange.text?.trim();
                console.log("📄 TextFrame content:", text);
                if (text) {
                  console.log("✅ Returning textFrame content:", text);
                  return text;
                }
              }
            } catch (textError) {
              console.error("❌ TextFrame extraction failed:", textError);
            }
          }
          
          // Try alternative text extraction methods
          console.log("🔄 Trying alternative text extraction methods...");
          try {
            // Method 1: Direct text property
            shape.load("text");
            await ctx.sync();
            if ((shape as any).text) {
              console.log("✅ Found direct text property:", (shape as any).text);
              return (shape as any).text.trim();
            }
          } catch (e) {
            console.log("❌ No direct text property available");
          }
        }
        
        console.log("❌ No extractable text found in any selected shapes");
      } else {
        console.log("❌ No shapes selected");
      }

      console.log("❌ No text found anywhere, returning empty string");
      return "";
      
    } catch (error) {
      console.error("💥 Fatal error in getPptSelectedTextOrShape:", error);
      console.error("Error details:", {
        name: error.name,
        message: error.message,
        stack: error.stack
      });
      throw error;
    }
  });
}

async function attemptTableExtraction(shape: PowerPoint.Shape, ctx: PowerPoint.RequestContext): Promise<string> {
  console.log("🏗️ Starting table extraction attempts...");
  
  // Method 1: Try Office.js table API (likely to fail)
  try {
    console.log("🔄 Method 1: Office.js table API");
    if (shape.table) {
      shape.table.load("rowCount,columnCount");
      await ctx.sync();
      console.log(`📊 Table dimensions: ${shape.table.rowCount} x ${shape.table.columnCount}`);
      // Continue with table extraction...
      return "Table found but extraction not yet implemented";
    }
  } catch (e) {
    console.log("❌ Method 1 failed:", e.message);
  }
  
  // Method 2: Try to access table through textFrame
  try {
    console.log("🔄 Method 2: Table via textFrame");
    if (shape.textFrame) {
      shape.textFrame.load("textRange");
      await ctx.sync();
      if (shape.textFrame.textRange) {
        shape.textFrame.textRange.load("text");
        await ctx.sync();
        const text = shape.textFrame.textRange.text;
        console.log("📄 Table textFrame content:", text);
        return text?.trim() || "";
      }
    }
  } catch (e) {
    console.log("❌ Method 2 failed:", e.message);
  }
  
  // Method 3: Try PowerPoint-specific approaches
  try {
    console.log("🔄 Method 3: PowerPoint-specific properties");
    // Load any PowerPoint-specific properties
    shape.load(); // Load all available properties
    await ctx.sync();
    
    // Log all available properties
    console.log("📋 All shape properties:", Object.keys(shape));
    
  } catch (e) {
    console.log("❌ Method 3 failed:", e.message);
  }
  
  console.log("❌ All table extraction methods failed");
  return "";
}
