/**
 * Returns selected text if any; otherwise the textual content of the selected shapes;
 * otherwise the entire presentation's textual content (all slides, tables, and groups).
 */
export async function getSelectedTextOrWholeDeck(): Promise<string> {
  return PowerPoint.run(async (context) => {
    const pres = context.presentation;

    // 1) If user has a text selection, return it
    const selectedText = pres.getSelectedTextRangeOrNullObject();
    await context.sync();
    if (!selectedText.isNullObject) {
      selectedText.load("text");
      await context.sync();
      const t = (selectedText.text ?? "").trim();
      if (t) return t;
    }

    const parts: string[] = [];

    // Helper: walk shapes (handles groups, tables, and text frames)
    const walkShapes = async (scoped: PowerPoint.ShapeScopedCollection) => {
      scoped.load("items/type");
      await context.sync();

      const frames: PowerPoint.TextFrame[] = [];
      const tables: PowerPoint.Table[] = [];
      const toRecurse: PowerPoint.ShapeScopedCollection[] = [];

      for (const shape of scoped.items) {
        if (shape.type === PowerPoint.ShapeType.group) {
          toRecurse.push(shape.group.shapes);
        } else if (shape.type === PowerPoint.ShapeType.table) {
          const table = shape.getTable();
          table.load("values,rowCount,columnCount");
          tables.push(table);
        } else {
          const tf = shape.getTextFrameOrNullObject();
          tf.load("hasText,textRange/text");
          frames.push(tf);
        }
      }
      await context.sync();

      // text frames
      for (const tf of frames) {
        if (!tf.isNullObject && tf.hasText && tf.textRange && typeof tf.textRange.text === "string") {
          const t = (tf.textRange.text || "").trim();
          if (t) parts.push(t);
        }
      }

      // tables
      for (const tb of tables) {
        for (let r = 0; r < tb.rowCount; r++) {
          for (let c = 0; c < tb.columnCount; c++) {
            const cell = (tb.values[r][c] ?? "").toString().trim();
            if (cell) parts.push(cell);
          }
        }
      }

      // recurse into groups
      for (const inner of toRecurse) {
        await walkShapes(inner);
      }
    };

    // 2) If shapes are selected, read them
    const selectedShapes = pres.getSelectedShapes();
    selectedShapes.load("items/type");
    await context.sync();

    if (selectedShapes.items.length > 0) {
      await walkShapes(selectedShapes);
      return parts.join("\n\n");
    }

    // 3) Otherwise, read the whole presentation
    const slides = pres.slides;
    slides.load("items");
    await context.sync();

    for (const slide of slides.items) {
      // slide content
      await walkShapes(slide.shapes);

      // notes page content (if supported in your client)
      const notesShapes = (slide as any).notesPage?.shapes as PowerPoint.ShapeScopedCollection | undefined;
      if (notesShapes) await walkShapes(notesShapes);
    }

    return parts.join("\n\n");
  });
}
