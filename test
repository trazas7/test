// npm i jszip
import JSZip from "jszip";

/**
 * Try: (1) selected text, (2) selected text box, (3) if a Table is selected (or nothing else),
 * parse the PPTX ZIP and extract tables (TSV). Very verbose logging included.
 */
export async function getPptSelectedTextOrShape(): Promise<string> {
  const t0 = performance.now();
  console.log("üöÄ [getPptSelectedTextOrShape] start");

  // track if we saw a Table in the selection so we know whether to prioritize that slide
  let sawSelectedTable = false;
  let activeSlideIndex: number | null = null;

  const textFromSelectionOrShape = await PowerPoint.run(async (ctx) => {
    try {
      console.log("üîé step 1: try highlighted text");
      const sel = ctx.presentation.getSelectedTextRangeOrNullObject();
      await ctx.sync();
      if (!sel.isNullObject) {
        sel.load("text");
        await ctx.sync();
        const t = (sel.text ?? "").trim();
        console.log("üñ±Ô∏è selected text:", JSON.stringify(t));
        if (t) return t;
      } else {
        console.log("‚ÑπÔ∏è no selected text range");
      }

      console.log("üîé step 2: check selected shapes");
      const shapes = ctx.presentation.getSelectedShapes();
      shapes.load("items");
      await ctx.sync();
      console.log("üì¶ selected shapes count:", shapes.items.length);

      if (shapes.items.length > 0) {
        // load text props on each shape
        shapes.items.forEach((s) =>
          s.load("type,name,hasText,textFrame/textRange/text")
        );
        await ctx.sync();

        // first see if a text box is selected
        for (const s of shapes.items as any[]) {
          console.log(
            `‚Ä¢ shape: name=${s.name} type=${s.type} hasText=${s.hasText}`
          );
          if (s.type === "TextBox" && s.textFrame?.textRange?.text) {
            const txt = (s.textFrame.textRange.text ?? "").trim();
            console.log("üìù text from TextBox:", JSON.stringify(txt));
            if (txt) return txt;
          }
          if (s.type === "Table") {
            sawSelectedTable = true;
          }
        }
      } else {
        console.log("‚ÑπÔ∏è no shapes selected");
      }

      // Nice-to-have: capture active slide index to narrow ZIP parsing later
      try {
        const slide = ctx.presentation.slides.getActiveSlide();
        slide.load("index");
        await ctx.sync();
        activeSlideIndex = (slide as any).index ?? null; // often 1-based
        console.log("üìç active slide index (host-reported):", activeSlideIndex);
      } catch (e) {
        console.log("‚ö†Ô∏è could not read active slide index:", e);
      }

      return ""; // fall through to ZIP parsing
    } catch (err) {
      console.error("üí• error during selection/textbox path:", err);
      return "";
    }
  });

  if (textFromSelectionOrShape?.trim()) {
    console.log(
      `‚úÖ [getPptSelectedTextOrShape] returning plain text in ${
        Math.round(performance.now() - t0)
      } ms`
    );
    return textFromSelectionOrShape.trim();
  }

  // If we‚Äôre here, either a table was selected or nothing readable was found.
  console.log(
    `üß≠ proceeding to ZIP parse (sawSelectedTable=${sawSelectedTable}, activeSlideIndex=${activeSlideIndex})`
  );
  try {
    const tZip0 = performance.now();
    const tsv = await readPptTablesAsTSV({
      preferSlideIndex: sawSelectedTable ? activeSlideIndex : null, // parse only selected slide‚Äôs XML if we know it
      fallbackAllSlides: true,
    });
    const ms = Math.round(performance.now() - tZip0);
    console.log(`üì¶ ZIP parse finished in ${ms} ms`);
    if (tsv.trim()) {
      console.log(
        `‚úÖ [getPptSelectedTextOrShape] returning TSV (${tsv.split("\n\n").length} table(s)) in ${
          Math.round(performance.now() - t0)
        } ms`
      );
      return tsv;
    }
    console.log("‚ùå ZIP parse produced no tables");
  } catch (zipErr) {
    console.error("üí• ZIP parse failed:", zipErr);
  }

  console.log(
    `ü´§ [getPptSelectedTextOrShape] nothing extracted in ${
      Math.round(performance.now() - t0)
    } ms`
  );
  return "";
}

/* --------------------------------------------------------------------------------------
 * ZIP parsing pipeline with LOTS of logs
 * ------------------------------------------------------------------------------------*/

type ReadTablesOpts = {
  /** 1-based slide index to prefer; if set we will parse only that slide‚Äôs XML. */
  preferSlideIndex?: number | null;
  /** If true and preferred slide not found, we parse all slides. */
  fallbackAllSlides?: boolean;
};

export async function readPptTablesAsTSV(
  opts: ReadTablesOpts = {}
): Promise<string> {
  const { preferSlideIndex = null, fallbackAllSlides = true } = opts;
  console.log(
    "üîß [readPptTablesAsTSV] opts:",
    JSON.stringify({ preferSlideIndex, fallbackAllSlides })
  );

  // 1) Download PPTX as zipped arraybuffer
  console.log("‚¨áÔ∏è fetching PPTX ZIP via Office.context.document.getFileAsync");
  const zipBuffer = await getPptxZipArrayBuffer();
  console.log("‚úÖ ZIP bytes:", (zipBuffer.byteLength / 1024).toFixed(1), "KB");

  // 2) Unzip with JSZip
  console.log("üßµ unzipping with JSZip...");
  const zip = await JSZip.loadAsync(zipBuffer);
  console.log("‚úÖ ZIP loaded; file count:", Object.keys(zip.files).length);

  // 3) List slide XMLs
  const allSlidePaths = Object.keys(zip.files).filter((p) =>
    /^ppt\/slides\/slide\d+\.xml$/.test(p)
  );
  console.log("üìÑ slide XMLs found:", allSlidePaths.length);

  allSlidePaths.sort((a, b) => {
    const na = parseInt(a.match(/slide(\d+)\.xml/)![1], 10);
    const nb = parseInt(b.match(/slide(\d+)\.xml/)![1], 10);
    return na - nb;
  });

  // If we know the preferred slide, try only that one
  let targets = allSlidePaths;
  if (preferSlideIndex && Number.isFinite(preferSlideIndex)) {
    const preferred = allSlidePaths.filter((p) =>
      p.endsWith(`slide${preferSlideIndex}.xml`)
    );
    console.log("üéØ preferred slide match:", preferred);
    if (preferred.length > 0) {
      targets = preferred;
    } else if (!fallbackAllSlides) {
      console.log("‚õî preferred slide not found, and fallback disabled");
      return "";
    } else {
      console.log("‚Ü™Ô∏è preferred slide not found, falling back to all slides");
    }
  }

  // 4) Parse target slides, collect TSV tables
  let out: string[] = [];
  for (const path of targets) {
    console.log("üß© parsing", path);
    const xmlText = await zip.files[path].async("text");
    const tsvBlocks = extractTablesFromSlideXML(xmlText);
    console.log(`   üìä tables found in ${path}:`, tsvBlocks.length);
    out.push(...tsvBlocks);
  }

  const result = out.join("\n\n").trim();
  console.log(
    "üßæ total tables extracted:",
    out.length,
    " total chars:",
    result.length
  );
  return result;
}

/** Stream the current deck into memory as a ZIP ArrayBuffer */
async function getPptxZipArrayBuffer(): Promise<ArrayBuffer> {
  const file = await getFileAsync(Office.FileType.Compressed);
  console.log("üì¶ file acquired:", {
    sliceCount: file.sliceCount,
    sizeEstimateKB: "unknown",
  });

  try {
    const chunks: Uint8Array[] = [];
    for (let i = 0; i < file.sliceCount; i++) {
      const slice = await getSliceAsync(file, i);
      const arr = slice.value.data as number[]; // host returns number[]
      const u8 = new Uint8Array(arr);
      chunks.push(u8);
      if (i === 0 || (i + 1) === file.sliceCount || (i + 1) % 10 === 0) {
        console.log(
          `   üîπ slice ${i + 1}/${file.sliceCount} (${u8.length} bytes)`
        );
      }
    }
    const totalLen = chunks.reduce((s, u) => s + u.length, 0);
    console.log("üìè total ZIP bytes:", totalLen);

    const merged = new Uint8Array(totalLen);
    let off = 0;
    for (const u of chunks) {
      merged.set(u, off);
      off += u.length;
    }
    return merged.buffer;
  } finally {
    file.closeAsync(() => console.log("üßπ file closed"));
  }
}

function getFileAsync(type: Office.FileType): Promise<Office.File> {
  return new Promise((resolve, reject) => {
    Office.context.document.getFileAsync(type, (res) => {
      if (res.status === Office.AsyncResultStatus.Succeeded) resolve(res.value);
      else {
        console.error("‚ùå getFileAsync failed:", res.error);
        reject(res.error);
      }
    });
  });
}

function getSliceAsync(file: Office.File, index: number) {
  return new Promise<Office.AsyncResult<Office.Slice>>((resolve, reject) => {
    file.getSliceAsync(index, (res) => {
      if (res.status === Office.AsyncResultStatus.Succeeded) resolve(res);
      else {
        console.error(`‚ùå getSliceAsync(${index}) failed:`, res.error);
        reject(res.error);
      }
    });
  });
}

/* --------------------------------------------------------------------------------------
 * XML parsing helpers with LOTS of logs
 * ------------------------------------------------------------------------------------*/

/** Parse one slide‚Äôs XML and return an array of TSV table strings */
function extractTablesFromSlideXML(xml: string): string[] {
  console.log("üî¨ parse slide XML (length:", xml.length, ")");
  const parser = new DOMParser();
  const doc = parser.parseFromString(xml, "application/xml");

  // Find all <a:tbl> (or any namespace tbl)
  const tables: Element[] = [
    ...Array.from(doc.getElementsByTagNameNS("*", "tbl")),
  ];
  console.log("üîé <tbl> count:", tables.length);

  const results: string[] = [];
  tables.forEach((tbl, idx) => {
    const tsv = tableElementToTSV(tbl, idx);
    if (tsv.trim()) results.push(tsv);
  });
  return results;
}

/** Convert <a:tbl> to TSV by walking <a:tr>/<a:tc> and collecting <a:t> text. */
function tableElementToTSV(tblEl: Element, tblIndex: number): string {
  const rows = Array.from(tblEl.getElementsByTagNameNS("*", "tr"));
  console.log(`üß± table#${tblIndex} rows:`, rows.length);

  const lines: string[] = [];
  for (let r = 0; r < rows.length; r++) {
    const tr = rows[r];
    const cells = Array.from(tr.getElementsByTagNameNS("*", "tc"));
    const cellValues = cells.map((tc, c) => {
      const txt = getTextFromCell(tc);
      console.log(`   ‚Ä¢ r${r}c${c} text=`, JSON.stringify(txt));
      return txt;
    });

    // Trim trailing empty cells for a cleaner TSV
    let end = cellValues.length;
    while (end > 0 && (!cellValues[end - 1] || !cellValues[end - 1].trim()))
      end--;
    const line = cellValues.slice(0, end).join("\t");
    lines.push(line);
  }

  // Remove trailing empty rows
  while (lines.length && !lines[lines.length - 1].trim()) lines.pop();

  const tsv = lines.join("\n");
  console.log(`üßæ table#${tblIndex} TSV length:`, tsv.length);
  return tsv;
}

/** Extract all text within a cell, respecting <a:br/> as newlines. */
function getTextFromCell(tc: Element): string {
  const doc = tc.ownerDocument!;
  const walker = doc.createTreeWalker(
    tc,
    NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT
  );

  let n: Node | null = walker.nextNode();
  let out = "";
  while (n) {
    if (n.nodeType === Node.ELEMENT_NODE) {
      const el = n as Element;
      if (el.localName === "t") out += el.textContent ?? "";
      else if (el.localName === "br") out += "\n";
    }
    n = walker.nextNode();
  }

  out = out.replace(/\s+\n/g, "\n").replace(/\n{3,}/g, "\n\n").trim();
  return out;
}