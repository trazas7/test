function toast(msg: string) {
  // replace with your UI; this keeps the sample self-contained
  console.log("[INFO]", msg);
}

async function getPptSelectedOrFullText(task: any): Promise<string> {
  return await PowerPoint.run(async (ctx) => {
    // 1) If a table shape is selected, guide the user
    const shapes = ctx.presentation.getSelectedShapes();
    shapes.load("items");
    await ctx.sync();

    if (shapes.items.length) {
      shapes.items.forEach(s => s.load("type"));
      await ctx.sync();
      const tableSelected = shapes.items.some((s: any) => s.type === "Table");
      if (tableSelected) {
        // 2) Try the safe text-range API — works ONLY if actual characters are selected in a cell
        const r = ctx.presentation.getSelectedTextRangeOrNullObject();
        await ctx.sync();
        if (!r.isNullObject) {
          r.load("text");
          await ctx.sync();
          const t = (r.text ?? "").trim();
          if (t) return t;
        }
        toast("Tip: double-click **inside a table cell** so the I-beam cursor is blinking, then **highlight the text** (e.g., Shift+End) and run again.");
        // Don’t try to read cells from the Table API — not supported in PPT Office.js.
      }
    }

    // 3) Normal case: selected text in a textbox / placeholder / inside a table cell
    const sel = ctx.presentation.getSelectedTextRangeOrNullObject();
    await ctx.sync();
    if (!sel.isNullObject) {
      sel.load("text");
      await ctx.sync();
      const t = (sel.text ?? "").trim();
      if (t) return t;
    }

    // 4) Optional fallback: collect all non-table text in deck (skip tables to avoid InvalidArgument)
    if (!task?.shouldSelectText && task?.name !== "AD_HOC") {
      return await collectAllNonTableText(ctx);
    }

    toast("No text selected. Highlight text in a textbox or inside a table cell and try again.");
    return "";
  });
}

async function collectAllNonTableText(ctx: PowerPoint.RequestContext): Promise<string> {
  const out: string[] = [];
  const slides = ctx.presentation.slides;
  slides.load("items");
  await ctx.sync();

  for (const slide of slides.items) {
    const shapes = slide.shapes;
    shapes.load("items");
    await ctx.sync();

    shapes.items.forEach(s => s.load("type"));
    await ctx.sync();

    for (const s of shapes.items as any[]) {
      if (s.type === "Group") {
        s.groupItems.load("items");
        await ctx.sync();
        s.groupItems.items.forEach((c: any) => c.load("type"));
        await ctx.sync();
        for (const c of s.groupItems.items as any[]) {
          if (c.type !== "Table") {
            c.load("textFrame/hasText,textFrame/textRange/text");
            await ctx.sync();
            if (c.textFrame?.hasText && c.textFrame?.textRange?.text) {
              const t = (c.textFrame.textRange.text || "").trim();
              if (t) out.push(t);
            }
          }
        }
      } else if (s.type !== "Table") {
        s.load("textFrame/hasText,textFrame/textRange/text");
        await ctx.sync();
        if (s.textFrame?.hasText && s.textFrame?.textRange?.text) {
          const t = (s.textFrame.textRange.text || "").trim();
          if (t) out.push(t);
        }
      }
    }
  }
  return out.filter(Boolean).join("\n");
}