// Works with older typings: avoids PowerPoint.Table type and shape.group typing.
// Returns the user's highlighted text if any; otherwise the text content
// from the selected shape(s) (text boxes, placeholders, tables, and groups).
export async function getPptSelectedTextOrShape(): Promise<string> {
  return PowerPoint.run(async (ctx) => {
    const pres = ctx.presentation;

    // 1) If there's an active text selection, prefer that.
    const sel = pres.getSelectedTextRangeOrNullObject();
    await ctx.sync();
    if (!sel.isNullObject) {
      sel.load("text");
      await ctx.sync();
      return (sel.text ?? "").trim();
    }

    // 2) Otherwise, get text from the selected shapes.
    const selected = pres.getSelectedShapes();
    selected.load("items/type");
    await ctx.sync();
    if (selected.items.length === 0) return "";

    const parts: string[] = [];

    // Recursively collect text from shapes. `any` is intentional to appease typings.
    const collect = async (scoped: any): Promise<void> => {
      scoped.load("items/type");
      await ctx.sync();

      const textFrames: any[] = [];
      const tables: any[] = [];
      const groups: any[] = [];

      for (const s of scoped.items) {
        // Table
        if (s.type === PowerPoint.ShapeType.table && (s as any).getTable) {
          const t = (s as any).getTable();
          t.load("values");
          tables.push(t);
        }
        // Text-bearing shapes
        if ((s as any).getTextFrameOrNullObject) {
          const tf = (s as any).getTextFrameOrNullObject();
          tf.load("hasText,textRange/text");
          textFrames.push(tf);
        }
        // Groups (typings may not expose `.group`, so use `any`)
        const g = (s as any).group;
        if (g?.shapes) groups.push(g.shapes);
      }

      await ctx.sync();

      for (const tf of textFrames) {
        if (!tf.isNullObject && tf.hasText && tf.textRange?.text) {
          const t = String(tf.textRange.text).trim();
          if (t) parts.push(t);
        }
      }

      for (const t of tables) {
        const vals: any[][] = t.values;
        if (Array.isArray(vals)) {
          const txt = vals.map(row => row.join("\t")).join("\n").trim();
          if (txt) parts.push(txt);
        }
      }

      for (const inner of groups) {
        await collect(inner);
      }
    };

    await collect(selected);

    return parts.join("\n\n");
  });
}
