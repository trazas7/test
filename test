/**
 * Robust whole-deck text dump with heavy logging.
 * Captures: text in text boxes/placeholders/auto-shapes, tables (values/cells), groups (recursive).
 * If something fails on a slide, it logs and continues.
 */
export async function dumpWholeDeckTextSafe(includeNotes = false): Promise<string> {
  return PowerPoint.run(async (context) => {
    const log = (...a: any[]) => console.log("[ppt-dump]", ...a);
    const started = Date.now();

    const slides = context.presentation.slides;
    slides.load("items/id,index,name");
    await context.sync();

    log(`slides found: ${slides.items.length}`);

    const deckOut: string[] = [];

    for (const slide of slides.items) {
      const slideHeader = `# Slide ${slide.index + 1}${slide.name ? ` â€” ${slide.name}` : ""}`;
      const slideParts: string[] = [slideHeader];

      try {
        // 1) First only load the count so we can log it clearly
        const s = slide.shapes;
        s.load("count");
        await context.sync();
        log("slide", { index: slide.index, id: slide.id, name: slide.name, shapeCount: s.count });

        // 2) Now load the actual items with the fields we need
        s.load(
          "items/id,name,type," +
          "items/textFrame/hasText," +
          "items/textFrame/textRange/text"
        );
        await context.sync();

        // 3) Collect from these shapes
        await collectFromShapes(s, slideParts, context, log, "slide");

        // 4) Optional notes
        if (includeNotes) {
          try {
            const notes = (slide as any).notesPage;
            if (notes?.shapes) {
              const ns = notes.shapes;
              ns.load("count");
              await context.sync();
              log("notes", { index: slide.index, count: ns.count });

              ns.load(
                "items/id,name,type," +
                "items/textFrame/hasText," +
                "items/textFrame/textRange/text"
              );
              await context.sync();

              const notesParts: string[] = [];
              await collectFromShapes(ns, notesParts, context, log, "notes");
              if (notesParts.length) {
                slideParts.push("Notes:");
                slideParts.push(notesParts.join("\n"));
              }
            }
          } catch (e) {
            log("notes error", e);
          }
        }
      } catch (e) {
        log("slide error", { index: slide.index, e });
      }

      deckOut.push(slideParts.join("\n"));
    }

    const result = deckOut.join("\n\n----\n\n");
    log("done", { slides: slides.items.length, length: result.length, ms: Date.now() - started });
    return result;
  });
}

/** Recursively read shapes. Loads are already done at caller for simple shapes; we only load extra for tables & groups. */
async function collectFromShapes(
  collection: PowerPoint.ShapeCollection | PowerPoint.ShapeScopedCollection,
  out: string[],
  ctx: PowerPoint.RequestContext,
  log: (...args: any[]) => void,
  where: "slide" | "notes" | "group"
) {
  // 1) fast path: text from already-loaded textFrame fields
  let textFrames = 0;
  let textFramesPushed = 0;

  for (const shape of (collection as any).items as PowerPoint.Shape[]) {
    // IMPORTANT: in the PowerPoint JS API the property is "type" (not "shapeType")
    const t = (shape as any).type; // enum PowerPoint.ShapeType
    const n = (shape as any).name;
    const id = shape.id;
    log("shape", { where, id, name: n, type: t });

    // text boxes / placeholders / autos with text
    try {
      const tf = (shape as any).textFrame as PowerPoint.TextFrame | undefined;
      if (tf && tf.hasText && tf.textRange && typeof tf.textRange.text === "string") {
        textFrames++;
        const txt = (tf.textRange.text || "").trim();
        if (txt) {
          out.push(txt);
          textFramesPushed++;
        }
      }
    } catch (e) {
      log("textFrame read error", { where, id, e });
    }
  }
  log("textFrames", { where, found: textFrames, pushed: textFramesPushed });

  // 2) tables (batch read)
  const tableJobs: { id: string; tbl: PowerPoint.Table }[] = [];
  for (const shape of (collection as any).items as PowerPoint.Shape[]) {
    if ((shape as any).type === PowerPoint.ShapeType.table) {
      try { tableJobs.push({ id: String(shape.id), tbl: shape.getTable() }); }
      catch (e) { log("getTable error", { where, id: shape.id, e }); }
    }
  }
  if (tableJobs.length) {
    for (const j of tableJobs) j.tbl.load("values,rowCount,columnCount");
    await ctx.sync();

    for (const { id, tbl } of tableJobs) {
      let pushed = false;
      try {
        const vals = (tbl as any).values as string[][] | undefined;
        if (Array.isArray(vals)) {
          const text = vals.map(r => r.map(v => (v ?? "").trim()).join("\t")).join("\n").trim();
          if (text) { out.push(text); pushed = true; log("table(values)", { where, id, rows: tbl.rowCount, cols: tbl.columnCount }); }
        }
      } catch { /* fall back */ }

      if (!pushed && typeof tbl.rowCount === "number" && typeof tbl.columnCount === "number") {
        const rows: string[] = [];
        for (let r = 0; r < tbl.rowCount; r++) {
          // load cells for the row in one go
          for (let c = 0; c < tbl.columnCount; c++) {
            const cell = tbl.getCellOrNullObject(r, c);
            cell.load("text");
          }
          await ctx.sync();

          const row: string[] = [];
          for (let c = 0; c < tbl.columnCount; c++) {
            const cell = tbl.getCellOrNullObject(r, c);
            row.push((cell.text ?? "").trim());
          }
          rows.push(row.join("\t"));
        }
        const t = rows.join("\n").trim();
        if (t) { out.push(t); log("table(cells)", { where, id, rows: tbl.rowCount, cols: tbl.columnCount }); }
      }
    }
  }

  // 3) groups (recurse)
  const groups: PowerPoint.ShapeScopedCollection[] = [];
  for (const shape of (collection as any).items as PowerPoint.Shape[]) {
    if ((shape as any).type === PowerPoint.ShapeType.group) {
      try { groups.push(shape.group.shapes); }
      catch (e) { log("group access error", { where, id: shape.id, e }); }
    }
  }
  for (const inner of groups) {
    // load the same fields for the nested collection before reading
    inner.load(
      "items/id,name,type," +
      "items/textFrame/hasText," +
      "items/textFrame/textRange/text"
    );
    await ctx.sync();
    await collectFromShapes(inner, out, ctx, log, "group");
  }
}
