// table-extract.ts
// npm i jszip
import JSZip from "jszip";

/**
 * Main entry ‚Äî returns either:
 *  ‚Ä¢ selected text (if text is highlighted), or
 *  ‚Ä¢ selected textbox text, or
 *  ‚Ä¢ TSV for the **selected table only** (matched by shape name in slide XML).
 *
 * It does **not** parse the whole deck unless a table is actually selected.
 */
export async function getPptSelectedTextOrShape(): Promise<string> {
  const t0 = performance.now();
  console.log("üöÄ [getPptSelectedTextOrShape] start");

  let selectedTableName: string | null = null;
  let activeSlideIndex: number | null = null; // optional; not available on all hosts

  const immediateText = await PowerPoint.run(async (ctx) => {
    try {
      // 1) Selected text range
      console.log("üîé step 1: try highlighted text");
      const sel = ctx.presentation.getSelectedTextRangeOrNullObject();
      await ctx.sync();
      if (!sel.isNullObject) {
        sel.load("text");
        await ctx.sync();
        const t = (sel.text ?? "").trim();
        console.log("üñ±Ô∏è selected text:", JSON.stringify(t));
        if (t) return t;
      } else {
        console.log("‚ÑπÔ∏è no selected text range");
      }

      // 2) Selected shapes ‚Üí textbox or table
      console.log("üîé step 2: inspect selected shapes");
      const shapes = ctx.presentation.getSelectedShapes();
      shapes.load("items");
      await ctx.sync();
      console.log("üì¶ selected shapes:", shapes.items.length);

      if (shapes.items.length > 0) {
        shapes.items.forEach((s) => s.load("type,name,textFrame/textRange/text"));
        await ctx.sync();

        for (const s of shapes.items as any[]) {
          console.log(`‚Ä¢ shape name=${s.name} type=${s.type}`);

          // Textbox returns directly
          const txt = s?.textFrame?.textRange?.text?.trim?.();
          if (s.type === "TextBox" && txt) {
            console.log("üìù returning textbox text");
            return txt;
          }

          // Table: capture name to target in XML
          if (s.type === "Table" && !selectedTableName) {
            selectedTableName = s.name ?? null;
            console.log("üìä table selected; name:", selectedTableName);
          }
        }
      } else {
        console.log("‚ÑπÔ∏è no shapes selected");
      }

      // 3) Optional: try to get active slide index (not on all hosts)
      const hasGetActiveSlide =
        (ctx.presentation as any).slides &&
        typeof (ctx.presentation as any).slides.getActiveSlide === "function";
      if (hasGetActiveSlide) {
        try {
          const slide = (ctx.presentation as any).slides.getActiveSlide();
          slide.load("index");
          await ctx.sync();
          activeSlideIndex = (slide as any).index ?? null; // typically 1-based
          console.log("üìç active slide index:", activeSlideIndex);
        } catch (e) {
          console.log("‚ö†Ô∏è could not read active slide index:", e);
        }
      } else {
        console.log("‚ÑπÔ∏è getActiveSlide not available on this host; will scan by name");
      }

      return "";
    } catch (err) {
      console.error("üí• error during selection scan:", err);
      return "";
    }
  });

  // If we already have plain text, return it.
  if (immediateText?.trim()) {
    console.log(`‚úÖ plain text path in ${Math.round(performance.now() - t0)} ms`);
    return immediateText.trim();
  }

  // If no table was selected, stop (we refuse to roam the whole deck).
  if (!selectedTableName) {
    console.log("‚õî no selected table name; not parsing entire deck");
    return "Select a single table, then try again.";
  }

  console.log(
    "üß≠ going to ZIP parse with filters:",
    JSON.stringify({ activeSlideIndex, selectedTableName })
  );

  // Parse only the selected table (match by shape name inside slide XML)
  const tsv = await readSelectedTableByNameTSV({
    selectedTableName: selectedTableName!,
    preferSlideIndex: activeSlideIndex ?? null,
  });

  if (tsv.trim()) {
    console.log(
      `‚úÖ returning selected table TSV in ${Math.round(performance.now() - t0)} ms`
    );
    return tsv;
  }

  console.log("‚ùå could not locate the selected table in slide XML");
  return "Couldn‚Äôt locate the selected table in the slide XML.";
}

/* ======================================================================================
 *  ZIP helpers
 * ====================================================================================*/

/** Stream the current deck into memory as a ZIP ArrayBuffer. */
async function getPptxZipArrayBuffer(): Promise<ArrayBuffer> {
  const file = await getFileAsync(Office.FileType.Compressed);
  console.log("üì¶ file acquired; slices:", file.sliceCount);
  try {
    const chunks: Uint8Array[] = [];
    for (let i = 0; i < file.sliceCount; i++) {
      const slice = await getSliceAsync(file, i);
      const u8 = new Uint8Array(slice.value.data as number[]);
      chunks.push(u8);
      if (i === 0 || i === file.sliceCount - 1 || (i + 1) % 10 === 0) {
        console.log(`   üîπ slice ${i + 1}/${file.sliceCount} (${u8.length} B)`);
      }
    }
    const total = chunks.reduce((s, u) => s + u.length, 0);
    console.log("üìè total bytes:", total);

    const merged = new Uint8Array(total);
    let off = 0;
    for (const u of chunks) {
      merged.set(u, off);
      off += u.length;
    }
    return merged.buffer;
  } finally {
    file.closeAsync(() => console.log("üßπ file closed"));
  }
}

function getFileAsync(type: Office.FileType): Promise<Office.File> {
  return new Promise((resolve, reject) => {
    Office.context.document.getFileAsync(type, (res) => {
      if (res.status === Office.AsyncResultStatus.Succeeded) resolve(res.value);
      else {
        console.error("‚ùå getFileAsync failed:", res.error);
        reject(res.error);
      }
    });
  });
}

function getSliceAsync(file: Office.File, index: number) {
  return new Promise<Office.AsyncResult<Office.Slice>>((resolve, reject) => {
    file.getSliceAsync(index, (res) => {
      if (res.status === Office.AsyncResultStatus.Succeeded) resolve(res);
      else {
        console.error(`‚ùå getSliceAsync(${index}) failed:`, res.error);
        reject(res.error);
      }
    });
  });
}

/* ======================================================================================
 *  Targeted: read ONLY the selected table by matching the shape name in slide XML
 * ====================================================================================*/

type ReadByNameOpts = {
  selectedTableName: string;        // e.g., "Table 4"
  preferSlideIndex?: number | null; // optional (1-based); if present, we check that slide first
};

/** Returns TSV for the first table whose <p:cNvPr name="‚Ä¶"> equals the selected shape name. */
async function readSelectedTableByNameTSV(opts: ReadByNameOpts): Promise<string> {
  const { selectedTableName, preferSlideIndex = null } = opts;
  console.log("üîß [readSelectedTableByNameTSV] opts:", opts);

  const nameCandidates = buildNameCandidates(selectedTableName);
  console.log("ü™™ name candidates:", nameCandidates);

  console.log("‚¨áÔ∏è fetching PPTX ZIP");
  const zipBuffer = await getPptxZipArrayBuffer();
  console.log("‚úÖ ZIP bytes:", (zipBuffer.byteLength / 1024).toFixed(1), "KB");

  const zip = await JSZip.loadAsync(zipBuffer);
  const slidePaths = Object.keys(zip.files)
    .filter((p) => /^ppt\/slides\/slide\d+\.xml$/.test(p))
    .sort((a, b) => {
      const na = parseInt(a.match(/slide(\d+)\.xml/)![1], 10);
      const nb = parseInt(b.match(/slide(\d+)\.xml/)![1], 10);
      return na - nb;
    });
  console.log("üìÑ slide XMLs:", slidePaths.length);

  // If we know the active slide, prioritize it (we‚Äôll still bail as soon as we find a match).
  let ordered = slidePaths.slice();
  if (preferSlideIndex) {
    const preferred = `ppt/slides/slide${preferSlideIndex}.xml`;
    ordered = [preferred, ...slidePaths.filter((p) => p !== preferred)];
    console.log("üéØ prioritizing", preferred);
  }

  for (const path of ordered) {
    console.log("üß© scanning", path);
    const xmlText = await zip.files[path].async("text");
    const tsv = findTableTSVByNameOnSlide(xmlText, nameCandidates);
    if (tsv) {
      console.log("‚úÖ match found on", path, "‚Üí returning TSV");
      return tsv;
    }
    console.log("‚Ä¶ no match on", path);
  }

  console.log("‚ùå no slide contained a matching table name");
  return "";
}

/* ======================================================================================
 *  XML helpers
 * ====================================================================================*/

/** Robust set of name variants to tolerate spacing/casing differences. */
function buildNameCandidates(name: string): string[] {
  const raw = name ?? "";
  const trimmed = raw.trim();
  const squashed = trimmed.replace(/\s+/g, " ");
  const nospace = squashed.replace(/\s+/g, "");
  const lower = squashed.toLowerCase();
  const lowerNo = nospace.toLowerCase();
  return Array.from(new Set([trimmed, squashed, nospace, lower, lowerNo]));
}

function normalizeName(n: string): string {
  return (n ?? "").trim().replace(/\s+/g, " ").toLowerCase();
}

/** Find the FIRST table on the slide whose graphicFrame cNvPr@name matches one of the candidates. */
function findTableTSVByNameOnSlide(xml: string, candidates: string[]): string {
  console.log(
    "üî¨ parse slide XML (len:",
    xml.length,
    ") candidates:",
    candidates
  );
  const doc = new DOMParser().parseFromString(xml, "application/xml");

  const frames = Array.from(doc.getElementsByTagNameNS("*", "graphicFrame"));
  console.log("üîé graphicFrame count:", frames.length);

  for (const gf of frames) {
    const nv = firstChildByLocalName(gf, "nvGraphicFramePr");
    const cNvPr = nv ? firstChildByLocalName(nv, "cNvPr") : null;
    const nameAttr = cNvPr?.getAttribute("name") ?? "";
    if (nameAttr) console.log("   ‚Ä¢ frame name:", JSON.stringify(nameAttr));

    if (
      nameAttr &&
      candidates.some((c) => normalizeName(nameAttr) === normalizeName(c))
    ) {
      console.log("üéØ matched by name:", nameAttr);
      const graphic = firstChildByLocalName(gf, "graphic");
      const graphicData = graphic ? firstChildByLocalName(graphic, "graphicData") : null;
      const tbl = graphicData ? firstChildByLocalName(graphicData, "tbl") : null;
      if (!tbl) {
        console.log("‚ö†Ô∏è matched frame has no <tbl>");
        return "";
      }
      return tableElementToTSV(tbl, 0);
    }
  }
  return "";
}

function firstChildByLocalName(parent: Element, local: string): Element | null {
  for (let i = 0; i < parent.childNodes.length; i++) {
    const n = parent.childNodes[i];
    if (n.nodeType === Node.ELEMENT_NODE && (n as Element).localName === local) {
      return n as Element;
    }
  }
  return null;
}

/** Convert <a:tbl> to TSV and log cell contents */
function tableElementToTSV(tblEl: Element, tblIndex: number): string {
  const rows = Array.from(tblEl.getElementsByTagNameNS("*", "tr"));
  console.log(`üß± table#${tblIndex} rows:`, rows.length);

  const lines: string[] = [];
  for (let r = 0; r < rows.length; r++) {
    const tr = rows[r];
    const cells = Array.from(tr.getElementsByTagNameNS("*", "tc"));
    const vals = cells.map((tc, c) => {
      const t = getTextFromCell(tc);
      console.log(`   ‚Ä¢ r${r}c${c} text=`, JSON.stringify(t));
      return t;
    });

    // Trim trailing empties for tidy TSV
    let end = vals.length;
    while (end > 0 && (!vals[end - 1] || !vals[end - 1].trim())) end--;
    lines.push(vals.slice(0, end).join("\t"));
  }
  while (lines.length && !lines[lines.length - 1].trim()) lines.pop();

  const tsv = lines.join("\n");
  console.log(`üßæ table#${tblIndex} TSV length:`, tsv.length);
  return tsv;
}

/** Extract text within a cell, honoring <a:br/> as newline. */
function getTextFromCell(tc: Element): string {
  const doc = tc.ownerDocument!;
  const walker = doc.createTreeWalker(
    tc,
    NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT
  );

  let n: Node | null = walker.nextNode();
  let out = "";
  while (n) {
    if (n.nodeType === Node.ELEMENT_NODE) {
      const el = n as Element;
      if (el.localName === "t") out += el.textContent ?? "";
      else if (el.localName === "br") out += "\n";
    }
    n = walker.nextNode();
  }
  return out.replace(/\s+\n/g, "\n").replace(/\n{3,}/g, "\n\n").trim();
}