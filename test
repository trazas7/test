async function getPptSelectedOrFullText(task: any): Promise<string> {
  return await PowerPoint.run(async (ctx) => {
    // --- Case A: user clicked a table (shape level)
    if (await isTableShapeSelected(ctx)) {
      // Try text range anyway (works only if the caret is *inside* a cell AND text is highlighted)
      try {
        const r = ctx.presentation.getSelectedTextRange();
        r.load("text");
        await ctx.sync();
        const t = (r.text ?? "").trim();
        if (t) return t;
      } catch { /* ignore */ }

      toast("Tip: click *inside* a table cell so the text cursor blinks, select the text you want (e.g., Shift+End), then run again.");
      // Don’t attempt to read table cells via API — unsupported on many builds.
    }

    // --- Case B: normal text selection (textbox, placeholder, or cell text actually selected)
    try {
      const r = ctx.presentation.getSelectedTextRange();
      r.load("text");
      await ctx.sync();
      const t = (r.text ?? "").trim();
      if (t) return t;
    } catch { /* ignore */ }

    // --- Case C: no selection → optional fallback to all non-table text
    if (!task.shouldSelectText && task.name !== "AD_HOC") {
      try {
        return await collectAllSlidesText(ctx); // defined below
      } catch { /* ignore */ }
    }

    toast("No text selected. Highlight text in a textbox or inside a table cell and try again.");
    return "";
  });
}


async function collectAllSlidesText(ctx: PowerPoint.RequestContext): Promise<string> {
  const out: string[] = [];
  const slides = ctx.presentation.slides;
  slides.load("items");
  await ctx.sync();

  for (const [i, slide] of slides.items.entries()) {
    const shapes = slide.shapes;
    shapes.load("items");
    await ctx.sync();

    shapes.items.forEach(s => s.load("id,name,type"));
    await ctx.sync();

    async function walk(s: any) {
      if (s.type === "Group") {
        s.groupItems.load("items");
        await ctx.sync();
        s.groupItems.items.forEach((c: any) => c.load("id,name,type"));
        await ctx.sync();
        for (const c of s.groupItems.items as any[]) await walk(c);
        return;
      }
      if (s.type === "Table") return; // skip – API can’t read cells reliably

      try {
        s.load("textFrame/hasText,textFrame/textRange/text");
        await ctx.sync();
        if (s.textFrame?.hasText && s.textFrame?.textRange?.text) {
          const t = (s.textFrame.textRange.text || "").trim();
          if (t) out.push(t);
        }
      } catch { /* ignore */ }
    }

    for (const s of shapes.items as any[]) await walk(s);
  }
  return out.filter(Boolean).join("\n");
}


async function isTableShapeSelected(ctx: PowerPoint.RequestContext): Promise<boolean> {
  const shapes = ctx.presentation.getSelectedShapes();
  shapes.load("items");
  await ctx.sync();

  if (!shapes.items.length) return false;
  shapes.items.forEach(s => s.load("type"));
  await ctx.sync();

  // If any selected shape is a table, return true
  return shapes.items.some((s: any) => s.type === "Table");
}





